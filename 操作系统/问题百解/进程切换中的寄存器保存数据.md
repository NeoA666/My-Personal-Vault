概念先导
- “内核栈”保存的是本次陷入内核时的“陷入帧/寄存器快照”（pt_regs），它跟随进程的内核栈一起存在，用来从系统调用/中断返回时恢复用户态寄存器。
- “进程结构”（PCB，Linux 中是 task_struct->thread_struct）保存的是能够在调度器进行进程切换时最小化恢复内核态执行所需的那部分上下文。

内核栈里会保存（pt_regs + 可能的切换帧）
- 由硬件/汇编入口压入的陷入帧（pt_regs），典型包含：
  - 通用寄存器：如 ax/cx/dx/bx/si/di/bp（或 x86_64: rax…，ARM: r0–r12 等）
  - 程序计数器/返回地址：IP/EIP/RIP 或 PC
  - 标志寄存器：FLAGS/EFLAGS/RFLAGS（或 CPSR/SPSR 等）
  - 段选择子/特权级切换信息：CS、SS（有的架构无段寄存器）
  - 在用户态与内核态切换时的用户态 SP/SS（若发生特权级切换）
  - 中断号/错误码（如果有）
- 有些架构/实现会在旧任务的内核栈上再留一个“switch frame”，保存调度返回地址和少量暂存寄存器（如 rbp），供 switch_to 返回时使用。

进程结构（task_struct->thread_struct）里会保存
- 能让调度器切走/切回的“最小上下文”，典型包含：
  - 内核栈指针（SP/ESP/RSP）
  - 调度返回用的指令位置（通常作为 switch_to 的返回地址隐含保存）
  - 被调用者需要保留的通用寄存器（callee-saved），如：
    - x86(32)：ebx、esi、edi、ebp
    - x86_64：rbx、rbp、r12–r15
    - 其他架构对应的 s/非易失寄存器
  - 段/基址类寄存器与 TLS 相关：如 FS/GS base（x86/x86_64）
  - FPU/SSE/AVX 向量浮点上下文（fxsave/xsave 区或等价结构）
  - 调试寄存器、架构特有状态（如 ARM 的 TLS 指针、VFP/NEON 上下文、RISC-V 的 s* 寄存器等）

要点
- “用户态寄存器集”通常不直接放进 task_struct，而是放在本次陷入形成的 pt_regs（内核栈顶附近）。信号处理、系统调用返回都依赖它。
- “调度用寄存器集”放在 thread_struct，只保存恢复内核态执行必需的最小集合；其余都在需要时由内核栈上的 pt_regs 恢复（返回用户态时）。

[[A_CPU虚拟化问题#^89baf5]]