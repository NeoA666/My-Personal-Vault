
概要

- “陷阱代码”（trap code）是指由硬件“异常/中断/系统调用向量”跳转到的内核端入口桩代码及其早期处理路径。它完成从用户态到内核态的受控切换：切特权级、切栈、保存最小上下文、建立安全的内核执行环境，然后再分派到真正的处理例程；返回时再把状态安全地还原回用户态。

它解决的核心问题

- 隔离：用户态不能随意执行内核地址空间或读写内核数据。
- 原子性/可重入性：入口早期阶段避免缺页、避免被抢占/打断（按场景屏蔽中断）。
- 完整性：保存/恢复足够的上下文，保证返回后用户态继续正确运行。
- 防利用：阻断从用户可控状态到内核执行的投机/间接跳转利用面。

通用工作流程（概念）

1. 预先设置

- 向量/表基址：x86 的 IDTR 和 LSTAR（SYSCALL），ARM64 的 VBAR_EL1，RISC‑V 的 stvec。
- 门/表项：每个异常号/中断号/系统调用都有入口地址和权限要求（如 x86 IDT gate 的 DPL）。
- 栈与每 CPU 数据：准备内核栈、NMI/双故障等专用 IST 栈（x86），或每 CPU 的栈指针保存槽（如 RISC‑V sscratch）。
- 页表与映射：入口桩和必要数据常驻、不可分页；KPTI 时准备用户可见的小跳板页以切换到完整内核页表。

2. 硬件进门（用户态触发）

- 选择器与特权切换：从 CPL=3/EL0/U 切到 CPL=0/EL1/S，并进行权限检查（例如 x86 IDT gate 的 DPL 限制从用户态只能走指定网关）。
- 保存极小状态：
    - x86 中断门会把 RIP/CS/RFLAGS/SS/RSP压到新栈；SYSCALL 把 RCX→RIP、R11→RFLAGS，CS/SS 改为内核固定值。
    - ARM64 把返回地址进 ELR_EL1，PSTATE 进 SPSR_EL1；RISC‑V 把返回地址进 sepc，并更新 sstatus。
- 切栈与屏蔽：按照门/异常类型切到内核栈（如 x86 IST），通常临时屏蔽同级中断，保证早期代码原子性。
- 跳到向量入口地址（即“陷阱代码”起点）。

3. 入口桩做的第一件事（软件）

- 切到内核完整页表（KPTI）：最小跳板用固定映射，把 TTBR0/satp/CR3 切换到含内核映射的页表。
- 建立每 CPU 上下文：例如 x86 的 SWAPGS 取得 per‑CPU 基址；RISC‑V 用 sscratch 取每 CPU 栈。
- 保存通用寄存器到栈上的陷阱帧；对异常类型记录错误码/号。
- 应用安全栅栏（按需要）：序列化/投机屏障、RSB 填充等，防止投机跨越边界。
- 选择具体处理例程（系统调用分派、页故障处理、信号/调度等）。

4. 返回到用户态（出门）

- 把系统调用返回值等写回寄存器；必要时执行 copy_to_user（带访问检查）。
- 恢复寄存器状态与控制位；切回用户页表（KPTI）。
- 执行返回指令：
    - x86：IRETQ（中断/异常）或 SYSRET/SYSEXIT（系统调用）；需保证用户 RIP/栈地址是规范且可访问。
    - ARM64：ERET；RISC‑V：SRET。
- 重新使能中断/抢占等，回到用户态执行。

三大主流架构要点

- x86‑64
    
    - IDT：中断门/陷阱门（区别在于进门时是否清 IF）；DPL 控制谁能调用（系统调用门允许 CPL=3）。
    - 系统调用：SYSCALL/LSTAR/SFMASK（或老式 SYSENTER/TSS 字段）；入口通常 SWAPGS、设 RSP 为内核栈、保存寄存器。
    - 栈：TSS 的 IST 为 NMI/双故障等提供独立栈。
    - 安全硬化：SMEP/SMAP 防止内核运行/读写用户页；KPTI 隔离；CET（shadow stack/IBT）与 RSB 缓解；W^X/NX。
- ARM64
    
    - 异常级：EL0→EL1；VBAR_EL1 指向向量表（按同步/IRQ/FIQ/SError 分 4 段）。
    - 硬件保存 ELR_EL1/SPSR_EL1；软件选择 SP_EL1 栈、切 TTBR0（PAN/KPTI），然后分派。
    - 安全硬化：PAN（Privileged Access Never）、BTI、PAC、KASLR、W^X。
- RISC‑V
    
    - U/S/M 模式；stvec（direct/vector 模式）；sepc/sstatus 保存返回点与中断开关。
    - 常用技巧：sscratch 暂存每 CPU 栈指针，早期入口用它切栈；随后保存寄存器并分派。
    - 安全硬化：SUM/UXL、KPTI 类似策略、W^X、CFI 等。

为什么“安全”

- 硬件强制的网关与权限检查：只能通过受控指令和表项进入；用户无法跳进任意内核地址。
- 受控上下文建立：早期必经的入口桩完成切栈/页表切换/状态保存，避免利用可控用户栈或页表。
- 内存与执行策略：不可分页的入口代码、W^X/NX、SMEP/SMAP/PAN 阻断从内核执行用户页与越权访问。
- 随机化与控制流保护：KASLR/FGKASLR、CFI/CFG、CET（x86）、PAC/BTI（ARM64）削弱 ROP/JOP。
- 返回路径验证：返回地址/段选择器/标志位的严格要求（例如 x86 SYSRET 对非规范地址会 GP），降低跳转劫持。

与“异常/中断/系统调用”的关系

- 都通过“陷阱代码”入口进入内核；差别在同步/异步与门类型不同：
    - 异常/故障（如缺页、除零）同步于当前指令。
    - 中断（IRQ/NMI）异步于当前代码。
    - 系统调用是软件指令触发的“受控异常”，专门开放给用户态的网关。

想深入看实现可从这些入口文件入手（不同内核/架构命名接近）：

- Linux x86‑64：arch/x86/entry/entry_64.S、arch/x86/kernel/traps.c、arch/x86/entry/common.c
- Linux ARM64：arch/arm64/kernel/entry.S、entry-common.c、exceptions.c
- Linux RISC‑V：arch/riscv/kernel/entry.S、traps.c 这些入口桩展示了上述切栈、保存上下文、KPTI 跳板与分派的具体指令序列。

[[A_CPU虚拟化问题#^f1143e]]