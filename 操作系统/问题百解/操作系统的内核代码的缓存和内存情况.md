不一定。分开看“CPU 缓存”和“内存（RAM）”：

- CPU 缓存（I-cache/D-cache/TLB）
  - 不会“常驻”。缓存由硬件按需填充，随时可能被替换或失效，也可能被刷新。一般操作系统不会也不能指望把异常/系统调用代码永久锁在缓存里（极少数架构有 cache locking，但通用 OS 基本不依赖它）。
  - TLB 同理。内核通常把关键映射标记为全局（x86 的 GLOBAL bit）或用 ASID 减少切换成本，但条目仍可被逐出，无法保证一直在 TLB 里。

- 内存（RAM）
  - 通用 OS（Linux/Windows/BSD）会**确保异常/中断/系统调用“入口路径”代码与陷阱/向量表始终常驻内存、不可换出并且始终可映射访问**。这包括：
    - 陷阱表/IDT/向量表本身及其表项指向的入口桩代码
    - 保存现场、切栈、切换特权级（如 x86-64 SYSCALL/LSTAR）等最短路径
    - 处理 NMI/双重故障等不能容忍缺页的路径，以及相应内核栈（如 IST）
  - 这些代码通常放在不可分页段，且在所有 CPU 上可见；Linux 里这类代码还常标记为 noinstr/ro_after_init 等以避免插桩和写时修改。Windows 中 ISR/DPC 等必须在非分页内存（NonPaged）段。
  - 非关键的“慢路径”有时可以是可分页的（例如 Windows 的 PAGE 段，在低 IRQL/合适上下文才会触发），但系统调用/异常的入口与早期处理绝不会是可分页的。
  - 可加载模块：驱动的中断例程若位于模块中，只要设备启用，该模块就会保持常驻且标记为不可分页；模块被卸载则相应处理程序不再驻留。Linux 的系统调用入口与调度等核心不在模块中。

- 额外说明
  - IDT/向量表必须一直在内存并保持有效映射，但并不要求一直在 CPU 缓存里。
  - KPTI 等机制会在用户态不映射内核页表；在进入内核（系统调用/中断）时切换到包含内核文本的页表，因此仍能保证这些入口代码可用。
  - 嵌入式/无虚存系统（XIP/ROM）中，“常驻内存”的语义不同（代码可能直接在 Flash/ROM 上执行），但同样没有“常驻缓存”的保证。

结论：
- 在内存中：异常处理和系统调用的入口与关键路径代码、以及陷阱/向量表，必须且通常始终常驻内存、不可分页、始终可映射访问。
- 在 CPU 缓存中：不保证常驻；是否在缓存完全由硬件的替换策略和运行时行为决定。

[[A_CPU虚拟化问题#^6d7532]]