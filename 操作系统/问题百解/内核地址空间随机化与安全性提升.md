简要结论
- 不一定相同。陷阱/中断向量表在启用分页/MMU后，硬件使用的是“虚拟地址”（线性地址），而不是固定的物理地址。现代内核通常启用内核地址空间随机化（KASLR），因此陷阱处理例程的虚拟地址每次开机都可能不同，间接映射到的物理页也可能变化。
- 是否“物理地址”每次都相同，取决于平台和内核配置：有的系统还启用“物理 KASLR”，会随机化内核镜像加载到内存中的物理位置；也有的（尤其嵌入式/早期阶段）是固定或基本稳定的。
- 随机化能提升安全性，但不是万能的：它提高了利用难度，需要配合信息泄露防护、W^X、SMEP/SMAP/PAN、CFI、KPTI/CET 等一起使用。

展开说明
1) 虚拟 vs 物理
- x86：IDTR 记录的是 IDT 的线性地址，IDT 项里存放陷阱/中断处理例程的偏移（也是线性地址）。启用分页后，这些都是通过页表映射到物理内存的“虚拟地址”。启用 KASLR 后，内核文本段的虚拟基址（以及处理例程地址）会在每次启动随机化。
- ARMv8/AArch64：VBAR_EL1 保存异常向量表基址；在开启翻译后这是虚拟地址，KASLR 会导致向量表与处理例程的虚拟位置发生变化。早期未开 MMU 前可能会临时用固定物理地址的向量表，之后切换到随机化后的虚拟地址。
- RISC‑V：stvec/mtvec 在相应特权级下指向陷阱入口；S 态在开启地址翻译后使用虚拟地址，Linux 等也支持（或逐步支持）KASLR，使入口地址在 VA 上随机化。M 态常见实现中无虚拟内存，早期多用物理地址。

2) 物理地址是否稳定
- 无物理 KASLR 时：内核镜像的物理加载位置常由引导程序和可用内存布局决定，很多通用平台上往往“看起来差不多”，但并非保证固定。
- 启用物理 KASLR 时：内核解压/加载会选择一个随机的物理偏移（满足对齐与内存空洞约束），因此内核文本的物理页框每次可能不同；这同时也让陷阱处理例程背后的物理页发生变化。
- 嵌入式/裸机/早期引导：常见固定物理向量地址（如早期 ARM 的低/高向量），待内核接管并开启 MMU 后再迁移。

3) 安全性影响
- 有帮助：KASLR 让攻击者难以直接定位内核函数/陷阱处理例程/常见 gadget 的地址，阻碍 ROP/JOP 等利用。
- 但非完整防护：信息泄露（越界读、侧信道）、指令/页表探测、微架构侧信道等可泄露随机化偏移；另外大页对齐会降低随机粒度。实际需要与只读页表、W^X、SMEP/SMAP（x86）、PAN（ARM）、CFI、KPTI/CET 等组合使用。

4) 实际系统举例（概览）
- Linux x86_64、ARM64：广泛支持内核 VA KASLR；部分平台/配置还支持物理 KASLR。IDT/VBAR 指向的向量表和处理例程地址会随 KASLR 改变。
- Windows、macOS/iOS：都有内核 ASLR；异常/中断入口地址随之变动。
- RISC‑V Linux：逐步完善 KASLR 支持，行为取决于内核版本与配置。

如果你提供具体架构（x86/ARM64/RISC‑V）与操作系统/内核版本，我可以更精确地说明该平台下陷阱表地址在物理/虚拟层面的随机化策略与粒度。

[[A_CPU虚拟化问题#^5372d7]]