# ⏱️ CPU 调度算法详解与 C 语言实现
---
## 1. 两个核心指标 (Metrics)

就像评价一家快递公司，我们通常看两个指标：

- **周转时间 (Turnaround Time)**：`完成时间 - 到达时间`。
    - _意义_：包裹从寄出到收货总共花了多久。**越短越好**，代表吞吐量高。
- **响应时间 (Response Time)**：`首次运行时间 - 到达时间`。
    - _意义_：你寄出包裹后，快递员多久上门来取件。**越短越好**，代表交互性好（不会让你觉得死机了）。

---

## 2. 经典调度算法

### 🐢 先到先得 (FCFS - First Come, First Served)

**原理**：最简单的排队模型。

- **比喻**：超市只有一个收银台，大家排队，谁先来谁先结账。不管你买了一瓶水还是满满一车货，都得按顺序来。

**C语言实现核心思路**： 本质就是**按 `arrival_time` 进行排序**。

C

```
// 假设 Process 结构体包含 arrival_time, burst_time(运行时间)
// 核心逻辑：按照到达时间排序，然后累加时间
void FCFS(Process p[], int n) {
    sort_by_arrival(p, n); // 先按到达时间排序
    
    int current_time = 0;
    for(int i = 0; i < n; i++) {
        // 如果 CPU 空闲且进程还没来，时间快进到进程到达时刻
        if (current_time < p[i].arrival_time) 
            current_time = p[i].arrival_time;
        
        // 首次执行时间就是当前时间（对于 FCFS）
        p[i].start_time = current_time; 
        
        // 执行任务
        current_time += p[i].burst_time; 
        
        // 记录完成时间
        p[i].completion_time = current_time;
    }
}
```

**⚠️ 重点拓展：护航效应 (Convoy Effect)** 你笔记中提到的“弊端1”有一个专业术语叫**护航效应**。

- **场景**：一个 CPU 密集型的大任务（大卡车）在前面慢吞吞地跑，后面堵了一堆 I/O 密集型的小任务（小轿车）。
- **后果**：小轿车本来只需要 1 秒就能过路口，结果被堵了 10 分钟。整个系统的平均等待时间急剧增加。

---

### 🐇 最短任务优先 (SJF - Shortest Job First)

**原理**：先到先得，同时到达时短任务优先。

- **比喻**：超市里的“10件以下商品快速通道”。不管你几点来的，只要你买的东西少，你就先结账。

**C语言实现核心思路**： 不能简单地按 `burst_time` 排序所有任务！因为**你只能调度那些“已经到达”的进程**。

C

```
void SJF(Process p[], int n) {
    int current_time = 0;
    int completed = 0;
    
    while(completed < n) {
        int idx = -1;
        int min_burst = 999999;
        
        // 1. 遍历所有进程，找出：
        //    a. 已经到达 (arrival <= current_time)
        //    b. 还没完成 (!is_completed)
        //    c. 运行时间最短 (burst < min_burst)
        for(int i = 0; i < n; i++) {
            if(p[i].arrival_time <= current_time && !p[i].is_completed) {
                if(p[i].burst_time < min_burst) {
                    min_burst = p[i].burst_time;
                    idx = i;
                }
            }
        }
        
        if(idx != -1) {
            // 找到了，执行它（非抢占，一气呵成）
            current_time += p[idx].burst_time;
            p[idx].completion_time = current_time;
            p[idx].is_completed = 1;
            completed++;
        } else {
            // 当前没有进程到达，CPU 空转
            current_time++;
        }
    }
}
```

---

### ⚡ 最短完成时间优先 (STCF / SRTF)

这是 SJF 的**抢占式 (Preemptive)** 版本。也叫 SRTF (Shortest Remaining Time First)。

**原理**：

- **比喻**：你在排队结账，虽然你只有 2 件商品，但正在结账的人有 100 件。在 STCF 模式下，收银员会把那个人赶走，先给你结账。

**C语言实现核心思路**： 必须以**时间片（如每1秒）**为单位进行循环，每一秒都要重新检查“现在谁剩余时间最少”。

C

```
void STCF(Process p[], int n) {
    int current_time = 0;
    int completed = 0;
    
    // 这里的 burst_time 需要保留原值，用 remaining_time 来计算
    for(int i=0; i<n; i++) p[i].remaining_time = p[i].burst_time; 

    while(completed < n) {
        int idx = -1;
        int min_remaining = 999999;
        
        // 寻找当前时刻，剩余时间最少的进程
        for(int i = 0; i < n; i++) {
            if(p[i].arrival_time <= current_time && p[i].remaining_time > 0) {
                if(p[i].remaining_time < min_remaining) {
                    min_remaining = p[i].remaining_time;
                    idx = i;
                }
            }
        }

        if(idx != -1) {
            // 记录首次响应时间
            if(p[idx].remaining_time == p[idx].burst_time)
                p[idx].start_time = current_time;

            // 只运行 1 个时间单位
            p[idx].remaining_time--;
            current_time++;

            if(p[idx].remaining_time == 0) {
                p[idx].completion_time = current_time;
                completed++;
            }
        } else {
            current_time++;
        }
    }
}
```

---

### 🎡 时间片轮转 (RR - Round Robin)

**原理**：公平分享。

- **比喻**：玩“抢椅子”游戏，或者类似“快速约会”。每个人只能聊 2 分钟，时间到必须换下一个。
- **核心考量**：时间片（Time Slice）的选择。
    - **太短**：上下文切换（保存寄存器、切栈等）太频繁，CPU 都在忙着切换，没空干活。
    - **太长**：退化成 FCFS，响应变慢。

**C语言实现核心思路**： 需要使用一个**队列**来管理就绪进程。

C

```
void RR(Process p[], int n, int time_slice) {
    // 需要一个队列来存放索引，这里简化演示，假设有一个 Queue q
    Queue q; 
    initQueue(&q);
    
    // 初始时，按到达时间入队
    // (实际实现稍微复杂，需要在时间推进过程中动态加入新到达的进程)
    // 这里展示核心处理逻辑：
    
    int current_time = 0;
    
    while(!isEmpty(&q) || has_unprocessed_jobs(p, n)) {
        // 1. 将新到达的进程加入队列
        check_new_arrivals(p, n, current_time, &q);

        if(isEmpty(&q)) {
             current_time++;
             continue;
        }

        int idx = dequeue(&q); // 取出队头
        
        // 2. 决定运行多久：取 剩余时间 和 时间片 的较小值
        int run_time = (p[idx].remaining_time < time_slice) ? 
                        p[idx].remaining_time : time_slice;
        
        // 记录响应时间
        if(p[idx].remaining_time == p[idx].burst_time)
             p[idx].start_time = current_time;

        // 3. 运行
        current_time += run_time;
        p[idx].remaining_time -= run_time;
        
        // 4. 这段时间内可能有新进程到达，必须先入队！
        check_new_arrivals(p, n, current_time, &q);

        // 5. 如果还没做完，排到队尾
        if(p[idx].remaining_time > 0) {
            enqueue(&q, idx);
        } else {
            p[idx].completion_time = current_time;
        }
    }
}
```

---

## 🎓 总结

- **FCFS**：最简单，但有**护航效应**，大任务会堵死小任务。
- **SJF**：解决了护航效应，吞吐量极佳，但**非抢占**导致它对实时性要求高的场景无能为力，且可能导致长任务饥饿。
- **STCF**：SJF 的**抢占版**，拥有理论上最优的周转时间，但长任务依然可能饿死。
- **RR**：牺牲了周转时间来换取极佳的**响应时间**，是现代分时系统的基石。其性能取决于**时间片**的大小（要在响应速度和上下文切换开销之间找平衡）。

### 💡 学习建议

你说得对，理解算法最好的方式就是写代码。 建议你先尝试完整实现 **FCFS** 和 **SJF**，因为它们只需要排序逻辑。 **STCF** 和 **RR** 涉及时间步进和队列管理，是操作系统的精髓，写出来会非常有成就感！