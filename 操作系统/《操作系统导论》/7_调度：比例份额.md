# ⚖️ 比例份额调度 (Proportional Share Scheduling)

与之前的调度器（MLFQ, SJF）不同，这类算法的目标不是“周转时间”或“响应时间”的极致优化，而是**公平（Fairness）**。

核心理念：**我不需要保证任务何时完成，但我保证它能拿到承诺比例的 CPU 时间。**

## 1. 彩票调度 (Lottery Scheduling)

### 🎟️ 核心机制

- **概念**：把 CPU 时间看作一场没完没了的抽奖。每个进程持有不同数量的**彩票 (Tickets)**。
- **实现**：
    1. **总票池**：计算所有进程的票数总和。
    2. **抽奖**：生成一个 `0 ~ total-1` 的随机数 `winning_ticket`。
    3. **遍历中奖**：遍历进程链表，累加票数，直到计数器超过中奖号码。
- **优化**：将列表按彩票数**递减排列**。
    - _原因_：如果你先检查持有大量彩票的“大户”，命中率更高，遍历次数就越少。
    - _比喻_：抽奖箱里如果一半都是张三的名字，先检查张三能让你更快结束搜索。

### 🔄 扩展机制 (三种花样)

1. **彩票货币 (Ticket Currency)**：
    - **层级汇率**：用户可以发自己的“私币”给手下的进程，系统会自动按汇率兑换成全局彩票。
    - _比喻_：你在美国（全局）用美元，但你可以给你的孩子（子进程）发“家务券”（私币）。孩子拿家务券来换零花钱时，你按汇率兑换。实现了**模块化管理**。
2. **彩票转让 (Ticket Transfer)**：
    - **借力**：客户端进程 A 请求服务端进程 B 帮忙。A 可以把自己的票“借”给 B。
    - _目的_：B 拿的票多了，跑得更快，就能更快把结果还给 A。互利共赢。
3. **彩票通胀 (Ticket Inflation)**：
    - **自我印钞**：进程可以自己修改自己的票数。
    - _前提_：必须在**相互信任**的环境（如你自己的几台虚拟机）。在多用户系统里这就是作弊。

### 📉 不公平指标 (Unfairness Metric, U)

- **定义**：`U = 第一个任务完成时间 / 第二个任务完成时间`（假设两者票数相同）。
- **U ≈ 1**：完美公平。
- **结论**：彩票调度依赖**随机性**。
    - **短期**：非常不公平（可能一直抽不到你）。
    - **长期**：趋向公平（大数定律）。
    - _这也导致了它不适合短任务。_

---

## 2. 步长调度 (Stride Scheduling)

彩票调度的最大由于是“随机性”导致短期可能不公平。步长调度决定消除随机性，做一个**确定性**的公平算法。

### 🦶 核心原理

- **票数与步长成反比**：
    - 公式：`stride = 大常数 / tickets`。
    - 票越多，步子越小（步频越快）。
- **行程值 (Pass Value)**：记录当前进程走了多远。
- **规则**：
    1. 每次选 **行程值最小** 的进程运行。
    2. 运行后，`pass += stride`。

### 🏃‍♂️ 形象比喻：长腿与短腿的赛跑

- 进程 A（票多，大户）：腿短（步长小），为了跟上队伍，它必须**拼命迈步子**（高频运行）。
- 进程 B（票少，散户）：腿长（步长大），偶尔迈一步就能跟上。
- **结果**：虽然频率不同，但大家的**总进度 (Pass Value)** 始终保持一致，非常公平。

---

## 3. 为什么说它们“用处不大”？(The Verdict)

你提到的“无用论”主要源于以下两个致命伤，导致它们没能成为 Windows/Linux 的默认调度器：

1. **票数分配难题 (The Assignment Problem)**：
    
    - 作为一个用户，你知道浏览器应该给 1000 票，文本编辑器给 500 票吗？还是 1001 票？
    - **没有标准**：用户不知道如何分配票数来达到期望的效果，这导致算法在通用 OS 中很难落地。
2. **新进程的无知 (State Issue)**：
    
    - 步长调度中，如果来了一个新进程，它的 `pass` 值设为多少？
    - 设为 0？那它会**垄断 CPU** 直到追上大家。
    - 设为当前最小值？那它是公平了，但步长调度的复杂性就上来了。

> **大师的注解**：虽然通用 OS 不用，但**Linux 的 CFS (Completely Fair Scheduler)** 借鉴了步长调度的思想（用 `vruntime` 代替 `pass`，用权重代替票数），解决了这些问题，成为了当今世界的霸主。所以你也算学到了霸主的前身！

---

## 💻 C语言代码实现 (大师特供版)

这里展示两个算法的核心调度逻辑。

C

```
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define BIG_NUMBER 10000 // 用于步长计算的大常数

typedef struct {
    int pid;
    int tickets;    // 彩票数
    int stride;     // 步长 ( stride = BIG_NUMBER / tickets )
    int pass;       // 行程值 (当前累积进度)
} Process;

// --- 1. 彩票调度 (Lottery) ---
Process* lottery_scheduler(Process procs[], int n) {
    int total_tickets = 0;
    for (int i = 0; i < n; i++) {
        total_tickets += procs[i].tickets;
    }

    // 核心：随机抽取
    int winner_ticket = rand() % total_tickets;
    int counter = 0;

    // 遍历寻找中奖者
    for (int i = 0; i < n; i++) {
        counter += procs[i].tickets;
        if (counter > winner_ticket) {
            return &procs[i];
        }
    }
    return NULL; // Should not happen
}

// --- 2. 步长调度 (Stride) ---
Process* stride_scheduler(Process procs[], int n) {
    Process* best = NULL;
    int min_pass = 2147483647; // INT_MAX

    // 核心：寻找 pass 值最小的进程（确定性）
    for (int i = 0; i < n; i++) {
        if (procs[i].pass < min_pass) {
            min_pass = procs[i].pass;
            best = &procs[i];
        }
    }
    
    return best;
}

// --- 模拟运行 ---
void run_simulation() {
    srand(time(NULL));
    
    // 初始化进程：A有100票，B有50票 (A应该是B的2倍速度)
    Process p[2] = {
        {1, 100, 0, 0}, 
        {2, 50, 0, 0}
    };
    
    // 计算步长
    p[0].stride = BIG_NUMBER / p[0].tickets; // 10000/100 = 100
    p[1].stride = BIG_NUMBER / p[1].tickets; // 10000/50 = 200

    printf("--- 步长调度模拟 (A票数是B两倍) ---\n");
    for (int tick = 0; tick < 5; tick++) {
        Process* current = stride_scheduler(p, 2);
        
        printf("Tick %d: 运行 P%d (Pass: %d)\n", tick, current->pid, current->pass);
        
        // 关键步骤：更新行程值
        current->pass += current->stride;
    }
}

int main() {
    run_simulation();
    return 0;
}
```

### 运行结果分析 (Stride)

Text

```
Tick 0: 运行 P1 (Pass: 0) -> P1加100，变100
Tick 1: 运行 P2 (Pass: 0) -> P2加200，变200
Tick 2: 运行 P1 (Pass: 100) -> P1加100，变200
Tick 3: 运行 P1 (Pass: 200) -> P1加100，变300 (因为同为200时，代码逻辑选了前面的P1，或者随机选)
Tick 4: 运行 P2 (Pass: 200) -> P2加200，变400
```

你会发现，A 运行了 3 次，B 运行了 2 次（趋近于 2:1），而且是非常平滑的交替，没有完全随机的剧烈波动。

## 🎓 总结

- **彩票调度**：基于**随机**。简单粗暴，易于实现高级特性（货币、转让），但短期不公平。
- **步长调度**：基于**确定性计数**。精准公平，但引入了新进程状态管理的难题。
- **历史地位**：虽然没有直接统治桌面 OS，但它们的思想催生了 **Linux CFS**，并统治了 **容器与虚拟化** 领域（你需要给 Docker 容器分配 30% CPU 时，底层逻辑就是类似的）。


最后来了句两种调度用处不大😅
哈哈，握个手！🤝 看到你最后那句吐槽“**最后来了句两种调度用处不大** 😅”，我忍不住笑了。确实，学了半天复杂的机制，结果课本告诉你“现在的操作系统基本不用”，这种心情就像学了全套屠龙术结果发现世界上没有龙。