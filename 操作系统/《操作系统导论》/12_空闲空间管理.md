# 第十七章：空闲空间管理 (Free-Space Management)

本章探讨的核心问题是：当管理的内存空间被划分为大小不一的碎片时，如何有效地管理空闲空间？这一问题不仅存在于用户态的内存分配库（如 `malloc` 和 `free`），也存在于操作系统管理物理内存的过程中。

## 1. 假设

为了深入理解问题本质，我们需要设定一些前提条件，并明确我们主要解决的困难——**外部碎片**。

### 核心问题：外部碎片 (External Fragmentation)

当空闲空间的总量足以满足一个分配请求，但没有一个单独的连续块大到足以处理该请求时，就发生了外部碎片。

- **例子**：堆中有 100 字节的空闲空间，被分成了两个不连续的 50 字节块。此时若申请 60 字节，虽然总空闲 > 60，但分配会失败。

*也有内部碎片，但内部碎片不是一般的内存分配方法会产生的结果*

### 基本假设

在讨论实现之前，我们对分配器（Allocator）做出以下假设：

1. **接口**：类似 C 语言的 `malloc()` 和 `free()`。
    - `malloc(size_t size)`：返回一个指向分配区域的指针 `void *`。
    - `free(void *ptr)`：接受一个指针，释放对应的内存。**注意：接口中并没有告诉库需要释放的大小。**
2. **管理对象**：主要关注**堆（Heap）**的管理。
3. **不可重定位**：这是最关键的约束。一旦内存分配给用户，我们就不能移动它（因为用户持有指向该内存的指针，移动会导致指针失效）。因此，我们无法通过**紧凑（Compaction）**来消除碎片。
4. **管理连续区域**：分配器管理的是一块大的、连续的字节区域。

> **🛑 误区警示**
> 
> - **误区**：认为碎片整理（Defragmentation）在任何内存管理系统中都是可行的。
> - **真相**：在 C/C++ 这种暴露裸指针的语言环境中，操作系统或运行时库无法移动已分配的内存块，因为它们不知道所有指向该内存的指针位置。只有在支持自动垃圾回收（GC）且对象引用被虚拟机管理的语言（如 Java）中，紧凑才是可行的。

---

## 2. 底层机制

在讨论策略之前，必须先解决两个机制问题：如何处理不同大小的请求（分割与合并），以及如何追踪已分配区域的大小。

### 2.1 分割与合并 (Splitting and Coalescing)

- **分割 (Splitting)**：当请求的空间小于某个空闲块时，分配器会将该空闲块分为两部分：一部分返回给用户，另一部分留在空闲列表中。
    - _例子_：空闲列表有一个 30 字节的块。用户申请 10 字节。分配器找到这个 30 字节块，切下 10 字节返回，剩下的 20 字节留在列表中。
- **合并 (Coalescing)**：当用户释放内存时，如果简单地将该块加入空闲列表，可能会导致列表中全是细小的碎片。合并机制会检查被释放块的**左右邻居**是否也是空闲的。如果是，则将它们合并成一个大块。
    - _例子_：地址 100-110 空闲，用户释放了 110-120。如果不合并，列表有两个 10 字节块；合并后，列表有一个 20 字节块（100-120）。

### 2.2 追踪已分配空间的大小

用户调用 `free(ptr)` 时不传入大小，分配器如何知道要释放多少字节？

- **头部 (Header)**：分配器会在返回给用户的内存块**之前**，额外存储哪怕一点点信息。
- **结构**：
    
    C
    
    ```
    typedef struct {
        int size;
        int magic; // 用于完整性检查
    } header_t;
    ```
    
- **内存布局**： `[ Header (8 bytes) | User Memory (Allocated bytes) ]` 指针 `ptr` 指向 User Memory 的起始位置。
- **计算**： 当用户调用 `free(ptr)`，分配器执行 `header_t *hptr = (void *)ptr - sizeof(header_t);` 来找到头部，从而读取 `size`。

> **🛑 误区警示**
> 
> - **误区**：认为 `malloc(10)` 就只占用了 10 个字节的堆空间。
> - **真相**：实际占用的空间 = 用户申请的大小 + 头结构大小。如果是微小的频繁分配（如大量 4 字节整数），头部开销（通常 8 字节或更多）可能会导致巨大的空间浪费。

### 2.3 嵌入空闲列表 (Embedding the Free List)

如何在其管理的内存内部构建一个列表来追踪空闲空间？我们不能调用 `malloc` 来为列表节点分配空间（鸡生蛋问题）。

- **方法**：直接在**空闲内存块本身**存储列表节点信息。
- **实现**：
    
    C
    
    ```
    typedef struct __node_t {
        int size;
        struct __node_t *next;
    } node_t;
    ```
    
    当一块内存（假设 4096 字节）空闲时，我们将前几个字节强制转换为 `node_t`，并在其中写入 `size=4096` 和 `next=NULL`。

---

## 3. 基本策略

如何从空闲列表中选择最合适的块来满足请求？这是减少碎片的关键。

### 3.1 最优匹配 (Best Fit)

- **策略**：遍历**整个**空闲列表，找到**大于等于**请求大小的块中**最小**的那个。
- **目的**：保留较大的空闲块供未来使用，尽量减少浪费。
- **缺点**：
    1. **性能差**：必须遍历整个列表。
    2. **碎片化**：通常会留下非常小、几乎无用的微小碎片（比如 30 字节块切分出 29 字节，剩下 1 字节）。

### 3.2 最差匹配 (Worst Fit)

- **策略**：遍历整个列表，找到**最大**的空闲块并切分。
- **目的**：切分后剩下的块依然很大，避免产生微小碎片。
- **缺点**：
    1. **性能差**：同样需要全列表遍历。
    2. **效果差**：实证研究表明它通常会导致更严重的碎片化，因为它快速消耗了大块内存。

### 3.3 首次匹配 (First Fit)

- **策略**：从列表头开始搜索，找到**第一个**足够大的块就返回。
- **优势**：**速度快**（不需要遍历全表）。
- **缺点**：列表开头部分会被分割成许多小碎片。

### 3.4 下次匹配 (Next Fit)

- **策略**：类似首次匹配，但下次搜索不从头开始，而是从**上一次查找结束的位置**开始。
- **优势**：避免了列表开头的碎片堆积，将分配操作均匀分布在整个内存区域。性能通常与首次匹配相当。

> **总结**：没有一种策略在所有情况下都是最优的。通常 **First Fit** 和 **Next Fit** 因其速度和尚可的效果而被广泛使用，而 **Best Fit** 在减少空间浪费方面较好但耗时。

---

## 4. 其他方式

除了上述基于列表的分配策略，还有更高级的方案。

### 4.1 分离空闲列表 (Segregated Lists)

如果某个应用程序经常申请特定大小的内存（例如频繁申请对象 A），通用的分配器效率太低。

- **机制**：维护多个独立的空闲列表，每个列表只管理特定大小的块（如：一个列表专管 16 字节块，一个专管 32 字节块）。
- **优势**：分配和释放极其快速（通常 O(1)），且由于块大小固定，没有外部碎片。
- **Slab 分配器 (Slab Allocator)**：
    - 这是 OS 内核（如 Linux, Solaris）中广泛使用的技术。
    - 内核为常见的内核对象（如锁、文件描述符、inode）预先分配对象缓存。
    - 如果缓存不足，再向通用内存分配器申请大块内存（Slab）。

### 4.2 伙伴系统 (Buddy Allocation)

- **机制**：将内存看作一个大的 2^N 块。
    - 当需要内存时，将当前块一分为二，直到找到刚好满足请求的最小 2^k 块。
    - 这种切分方式确保了每个块都有一个唯一的“伙伴”（Buddy）。
- **合并的优势**：
    - 在伙伴系统中，合并变得极其简单。释放一个块时，只需检查其伙伴是否空闲。
    - 伙伴的地址可以通过简单的二进制运算得出（地址只相差一位）。
    - _例子_：如果你持有地址 0x1000 的 4KB 块，其伙伴必定是 0x0000 或 0x2000 中的一个（取决于对齐）。
- **缺点**：**内部碎片**。如果你申请 33KB，它必须给你分配 64KB 的块，浪费了 31KB。

---

## 5. 小结

空闲空间管理是操作系统和运行时系统的基石。

1. **核心矛盾**：在**速度**（分配性能）和**空间利用率**（最小化碎片）之间做权衡。
2. **关键机制**：
    - **头部**：隐藏在指针前的元数据，用于记录大小。
    - **嵌入列表**：利用空闲内存本身存储链表指针。
    - **合并**：防止内存变成无数不可用的小碎片。
3. **现实应用**：
    - 通用的 `glibc` 分配器通常结合了复杂的策略（如针对小对象的隔离列表和针对大对象的 mmap）。
    - 在编写高性能系统时，针对特定对象的**对象池（Object Pool）**或 **Slab 分配器** 往往比通用 `malloc` 性能好得多。

> **最后一点思考**：理解 `malloc` 的内部机制对于调试 **C/C++ 内存错误**（如 Double Free, Buffer Overflow 覆盖头部）至关重要。很多时候，程序崩溃在 `free()` 内部，是因为你越界写坏了下一个块的 Header。