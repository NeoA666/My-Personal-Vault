# 第 16 章：分段 (Segmentation)

在前面的章节中，我们学习了**虚拟内存**的最基础实现：**基址/界限 (Base and Bounds)**。虽然它很高效，但存在一个巨大的问题：**内部碎片 (Internal Fragmentation)**。

- **问题回顾**：如果一个进程的地址空间中有大块的“空闲空间”（例如堆和栈之间的巨大缺口），使用简单的基址/界限方案，这部分空闲空间仍然会占据物理内存。这太浪费了！

本章介绍的 **分段 (Segmentation)** 机制，就是为了解决这个问题，实现更高效的内存虚拟化。

---

## 1. 泛化的基址/界限 (Segmentation: Generalized Base/Bounds)

为了解决“空闲空间浪费”的问题，分段的核心思想是：**不再把整个进程地址空间看作一个整体，而是将其拆分为逻辑上的几段 (Segments)**。*段在这里指的是不同的逻辑段，而不是一个包含了代码，堆和栈的段*

### 核心概念

我们在 MMU（内存管理单元）中，不只是保存**一对**基址和界限寄存器，而是为地址空间中的**每一个逻辑段**都保存一对基址和界限寄存器。

典型的地址空间通常包含三个逻辑段：

1. **代码段 (Code)**：存放指令。
2. **栈段 (Stack)**：存放局部变量、函数参数等。
3. **堆段 (Heap)**：存放动态分配的内存。

### 例子：映射过程

假设有一个 16KB 的地址空间，被分段映射到物理内存中：

- **代码段**：虚拟地址 0KB ~ 2KB -> 映射到物理地址 32KB
- **堆段**：虚拟地址 4KB ~ 7KB -> 映射到物理地址 34KB
- **栈段**：虚拟地址 14KB ~ 16KB -> 映射到物理地址 28KB

**严谨说明**： 在分段机制下，只有**使用中**的内存段才会被分配物理空间。上例中，虚拟地址 2KB~~4KB 和 7KB~~14KB 之间的空闲区域，在物理内存中**不占用任何空间**。这就是分段最大的优势。

### ⚠️ 误区警示

- **误区**：分段意味着物理内存必须连续。
    - **纠正**：每个段在物理内存中确实是连续的，但**不同段之间在物理内存中不需要连续**。它们可以散落在物理内存的任意位置。
- **误区**：分段完全消除了碎片。
    - **纠正**：分段消除了**内部碎片**（空闲的堆栈间隙不再占用物理内存），但引入了**外部碎片**（External Fragmentation），后面会细说。

---

## 2. 我们引用哪个段？ (Which Segment Are We Referring To?)

硬件在进行地址转换时，如何知道一个虚拟地址属于哪个段（代码、堆还是栈）？

### 显式方式 (Explicit Approach)

通常使用虚拟地址的**高几位 (Top Bits)** 来标识段号。

假设我们有 14 位的虚拟地址（总共 16KB）：

- **高 2 位**：用于表示段号 (Segment ID)。
    - `00`: 代码段
    - `01`: 堆段
    - `10`: 栈段
    - `11`: 未使用
- **低 12 位**：表示段内偏移量 (Offset)。

**转换公式**：

Code

```
物理地址 = 基址[段号] + 偏移量
```

**例子**： 访问虚拟地址 `4200` (二进制 `01 0000 0110 1000`)。

1. 提取高 2 位 `01` -> 这是一个**堆段**引用。
2. 提取低 12 位 `0000 0110 1000` -> 偏移量是 104。
3. 查寄存器表：堆段基址是 34KB (34816)。
4. 物理地址 = 34816 + 104 = 34920。
5. **检查界限**：如果偏移量 104 小于堆段的界限（Limit），则访问合法；否则触发**段错误 (Segmentation Fault)**。



### 隐式方式 (Implicit Approach)

硬件通过指令类型来推断：

- 如果取指令 -> 代码段。
- 如果操作栈指针 (SP/BP) -> 栈段。
- 其他情况 -> 堆段。

---

## 3. 栈怎么办？ (What About The Stack?)

栈有一个特殊的属性：**它是向低地址方向增长的 (Backwards Growth)**。

为了支持这种特性，硬件寄存器中需要增加一个**增长方向 (Grows Positive/Negative)** 的位。

### 映射逻辑

如果是栈段（反向增长）：

- 在虚拟地址空间中，栈是从高地址开始的（例如 16KB）。
- 计算偏移量时需要特殊处理。

**例子**： 假设栈段基址在物理地址 28KB，大小限制为 2KB。 虚拟地址空间中，栈底在 16KB。 如果我们访问虚拟地址 15KB：

*认知纠正：栈在虚拟内存空间和物理内存空间中都是反响增长的*

1. 硬件识别这是栈段。
2. 计算负向偏移： `15KB - 16KB = -1KB` (或者用补码表示)。
3. 物理地址 = 基址 + 负偏移 = `28KB - 1KB` = 27KB。

**严谨说明**： 实际硬件实现通常更复杂，偏移量的计算方式可能不同，但核心原则是：**必须知道段是正向还是反向增长，才能正确进行边界检查和地址加法**。

---

## 4. 支持共享 (Support for Sharing)

分段不仅仅是为了节省内存，还可以实现**内存共享**。最典型的例子是**共享库 (Shared Libraries)** 或**代码共享**。

- **场景**：如果你运行了 10 个记事本程序，没必要在内存中存 10 份相同的代码指令。
- **实现**：让这 10 个进程的**代码段**基址都指向同一块物理内存区域。

### 保护位 (Protection Bits)

为了安全地共享，我们需要为每个段增加**保护位**：

- **Read (R)**
- **Write (W)**
- **Execute (X)**

**代码段设置**：`Read-Execute` (RX)，禁止写入。这样即便多个进程共享代码，坏进程也无法修改指令导致其他进程崩溃。

*带来硬件算法的更新，硬件需要检查特定操作是否被允许并返回给操作系统处理*

---

## 5. 细粒度与粗粒度的分段 (Fine-grained vs. Coarse-grained Segmentation)

- **粗粒度 (Coarse-grained)**：像我们上面讨论的，把地址空间分成少数几个大段（代码、堆、栈）。这很简单，也够用了。
- **细粒度 (Fine-grained)**：早期的某些系统（如 Burroughs B5000）允许将地址空间切分成成百上千个小段（例如每个函数、每个数组都是一个段）。
    - **优点**：极高的灵活性，更便于共享细小的逻辑单元。
    - **缺点**：需要更复杂的硬件支持（段表通常存在内存中，而不是寄存器中），开销大。

---

## 6. 操作系统支持 (OS Support)

引入分段后，操作系统有了新的职责：

### A. 上下文切换 (Context Switch)

当切换进程时，OS 必须保存当前进程的段寄存器，并加载新进程的段寄存器（基址/界限/保护位等）。

### B. 管理空闲空间：外部碎片 (External Fragmentation)

这是分段机制**最大、最头痛的问题**。

- **现象**：由于不同进程的段大小不一（有的段 1KB，有的 10KB），物理内存会被切分成各种大小不一的“洞”。
- **后果**：即使物理内存总剩余量够大（例如剩余 20KB），但如果它们分散成 20 个 1KB 的碎片，你也无法为一个需要 5KB 连续空间的段分配内存。
- **解决方案**：
    1. **紧凑 (Compaction)**：也就是“内存整理”。暂停运行进程，把所有段拷贝到一起，把空闲空间挤出来。
        - _缺点_：拷贝内存非常慢，CPU 占用极高。
    2. **空闲列表管理算法**：使用 Best-Fit（最佳匹配）、First-Fit（首次匹配）等算法尽量减小碎片。
        - _结论_：只能缓解，无法根除。

### ⚠️ 误区警示

- **误区**：分段机制下，malloc() 分配的内存不需要连续。
    - **纠正**：在**段内部**，虚拟地址必须是连续的，对应的物理地址也必须是连续的。分段只是让**不同段之间**不需要连续。如果你申请一个巨大的数组，它必须在一个段内，因此需要一块巨大的连续物理内存。

---

## 7. 小结 (Summary)

分段机制是内存虚拟化历史上的重要一步。

- **优点**：
    1. **解决了内部碎片**：稀疏地址空间不再浪费物理内存。
    2. **支持共享**：代码共享变得容易。
    3. **动态增长**：栈和堆可以独立增长。
- **缺点**：
    1. **外部碎片**：这是致命伤。变长的段导致物理内存管理变得极其复杂且低效。
    2. **不够灵活**：如果一个本来很小的稀疏地址空间突然变得很大，仍然需要通过复杂的机制来处理。

**预告**：为了解决外部碎片问题，我们最终将走向现代操作系统的标准解决方案——**分页 (Paging)**。