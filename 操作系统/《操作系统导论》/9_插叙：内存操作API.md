# 🛠️ 内存操作 API 与常见陷阱

## 1. 两种内存战场：栈 (Stack) vs 堆 (Heap)

C 程序运行时，数据主要生活在两个截然不同的区域：

|特性|栈内存 (Stack Memory)|堆内存 (Heap Memory)|
|---|---|---|
|**管理方式**|**自动管理** (Implicit)。编译器负责。|**手动管理** (Explicit)。程序员全权负责。|
|**生命周期**|函数调用时分配，返回时自动销毁。|从 `malloc` 开始，直到 `free` 结束。|
|**用途**|局部变量、函数参数、返回地址。|动态数据结构（链表、树）、大数组。|
|**比喻**|餐馆里的**自助餐盘**。用完服务员立马收走。|你租的**仓库**。你不退租，仓库永远在那。|

---

## 2. 核心 API 详解

### 📥 `malloc()`: 申请资源

- **原型**：`void *malloc(size_t size)`
- **参数**：需要申请的字节数。
- **返回值**：
    - 成功：返回指向新内存起始地址的指针（`void*`，需要转换）。
    - 失败：返回 `NULL`。
- **最佳实践**：永远配合 `sizeof()` 使用，不要硬编码数字。
    
    C
    
    ```
    int *x = (int *) malloc(10 * sizeof(int)); // 申请一个能存10个int的数组
    ```
    

### 📤 `free()`: 归还资源

- **原型**：`void free(void *ptr)`
- **参数**：必须是 `malloc`（或 `calloc`, `realloc`）返回的那个指针。
- **神奇之处**：你只需传指针，不用传大小。
    - _原理_：内存分配库会在返回给你的指针**之前**的几个字节里，悄悄记录这块内存的大小。这叫**元数据 (Metadata)**。如果你乱改指针位置再 `free`，程序就会炸。

---

## 3. ☠️ 内存错误的七宗罪 (Common Errors)

这些错误是 C 语言程序员的噩梦，必须熟记于心。

### 1. 忘记分配内存 (Segfault)

C

```
char *src = "hello";
char *dst; // 这是一个野指针，没分配空间
strcpy(dst, src); // 💥 崩溃！试图往非法地址写数据
```

### 2. 忘记初始化 (Uninitialized Read)

`malloc` 给你的内存里可能是上次用剩的垃圾数据。

C

```
int *x = malloc(sizeof(int));
printf("%d", *x); // 😱 输出可能是 1234567 或 -999
```

- **解法**：用 `memset` 清零，或者直接用 `calloc`。

### 3. 缓冲区溢出 (Buffer Overflow)

C

```
char *src = "hello"; // 5个字符 + 1个结束符'\0' = 6字节
char *dst = malloc(strlen(src)); // ❌ 只申请了5字节，忘了存 '\0'
strcpy(dst, src); // 💥 溢出！写到了分配区域之外
```

### 4. 悬挂指针 (Dangling Pointer)

C

```
int *x = malloc(sizeof(int));
free(x); // 归还了
printf("%d", *x); // ❌ 还在用！这块地已经归还给系统了，可能被别人借走了
```

- **解法**：`free(x)` 后立刻写 `x = NULL;`。

### 5. 内存泄漏 (Memory Leak)

C

```
void loop() {
    int *x = malloc(100);
    // ... 做事，但忘了 free(x)
} 
// 函数结束，指针 x 没了，但那 100 字节内存还在堆里，再也找不回了。
```

- **后果**：短时间没关系（OS 会在进程结束时统一回收），但在服务器或长时间运行的程序中，这会导致内存耗尽（OOM），系统变慢甚至杀掉进程。

### 6. 重复释放 (Double Free)

C

```
free(x);
free(x); // 💥 崩溃！内存库会感到困惑。
```

### 7. 无效释放 (Invalid Free)

C

```
int x;
free(&x); // 💥 崩溃！这是栈内存，不是堆内存，不能 free。
// 或者
int *arr = malloc(100);
free(arr + 1); // 💥 崩溃！必须传 malloc 返回的起始地址。
```

---

## 4. OS 底层支持 (Under the Hood)

你调用的 `malloc` 和 `free` 并不是直接的系统调用，它们是 C 库（libc）提供的**库函数**。库函数在底层维护了一个空闲列表，只有当堆空间不够时，才会找操作系统要地皮。

### 系统调用：`brk` 和 `sbrk`

- **作用**：调整堆（Heap）的顶端位置（Program Break）。
- **原理**：堆是向高地址增长的。
    - `sbrk(100)`：把堆顶向上推 100 字节（扩容）。
    - `sbrk(-100)`：把堆顶向下缩 100 字节（缩容）。
- **现代 OS**：除了 `brk`，现代 `malloc` 对于大块内存申请（如大于 128KB），通常会直接使用 `mmap()` 系统调用，在堆之外单独开辟一块虚拟内存。

---

## 5. 其他好用的工具 (Utils)

- **`calloc(num, size)`**：
    - **Call**ocate + **Clear**。
    - 分配 `num * size` 大小，并**自动清零**。防止读取未初始化数据的错误。
- **`realloc(ptr, new_size)`**：
    - **Re**size。
    - 尝试在原地扩容。如果原地没位置了，它会：
        1. 找块新地皮。
        2. 把旧数据**复制**过去。
        3. 自动 **free** 掉旧地皮。
        4. 返回新指针。
    - _易错点_：如果 `realloc` 失败返回 NULL，原来的 `ptr` 还在，千万别直接 `ptr = realloc(ptr...)`，这会导致内存泄漏！

---

## 🎓 总结

内存管理是 C 语言的“达摩克利斯之剑”。

1. **栈**是保姆，自动且安全；**堆**是自由市场，灵活但危险。
2. `malloc` 和 `free` 必须成对出现，就像“借钱”和“还钱”。
3. 底层通过 `brk/sbrk` 调整堆边界，通过元数据记录大小。
4. **Valgrind** 是你的好朋友，用它来检测内存泄漏和非法访问。