# 🏗️ 内存虚拟化初探：基址与界限技术

## 1. 引入：如何实现高效且受控的虚拟化？

*   **回顾**：我们通过 LDE（受限直接执行）实现了 CPU 虚拟化。
*   **目标**：现在我们要对内存做同样的事。
    *   **高效**：地址转换必须极快（硬件级）。
    *   **控制**：确保进程只能访问自己的地盘，不能越界。
    *   **透明**：进程完全不知道自己被从物理地址 `0` 挪到了物理地址 `32KB`。

## 2. 核心机制：动态重定位 (Base and Bounds)

这是最古老但也最直观的硬件虚拟化方案。

### 🛠️ 硬件主角：MMU (Memory Management Unit)
CPU 中多加了两个神奇的寄存器，它们构成了最简单的 MMU：

1.  **基址寄存器 (Base Register)**：
    *   作用：记录进程在物理内存中的**起始位置**。
    *   *比喻*：进程以为自己住在 1 楼（虚拟地址 0），实际上整栋楼被搬到了 100 楼（基址 32KB）。基址就是那个“偏移量”。
2.  **界限寄存器 (Bounds Register)**：
    *   作用：记录进程的**大小**（或者物理内存的结束位置）。
    *   *比喻*：围栏。防止进程梦游走到隔壁邻居（其他进程）家里去。

### 🔄 地址转换公式 (The Translation)
当程序执行一条指令（如 `Load 10`，读取虚拟地址 10 的数据）时：

```text
物理地址 = 虚拟地址 + 基址
Physical Address = Virtual Address + Base
```

*   例如：如果 Base = 32KB (32768)，程序想访问虚拟地址 10。
*   硬件实际访问的是：`32768 + 10 = 32778`。

### 🛡️ 保护机制 (Protection)
在访问物理内存前，MMU 会先做检查：

```c
if (虚拟地址 >= 界限) {
    触发异常 (Trap: Out of Bounds);
} else {
    物理地址 = 虚拟地址 + 基址;
    访问内存(物理地址);
}
```
*   一旦越界，CPU 触发异常，操作系统介入，通常会直接杀死该进程（Segment Fault）。

---

## 3. 硬件支持总结 (Summary of Hardware Requirements)


| 功能 | 为什么需要？ |
| :--- | :--- |
| **特权模式 (Privileged Mode)** | 防止用户进程乱改基址/界限寄存器（否则它就能访问任意内存了）。 |
| **基址/界限寄存器** | 每个 CPU 一对，用于实现地址转换和越界检查。 |
| **地址转换与检查电路** | 在**每条**指令执行时，硬件自动进行计算和检查（速度必须极快）。 |
| **修改基址/界限的特权指令** | 让 OS 在启动程序或切换进程时，能更新这两个寄存器。 |
| **注册异常处理程序** | 告诉硬件，当发生越界异常时，去哪里运行 OS 的代码。 |
| **触发异常** | 当非法访问发生时，暂停进程，切到内核态。 |

---

## 4. 操作系统的职责 (OS Responsibilities)

硬件只是提供了工具，真正干活的还是 OS。

1.  **内存分配 (Allocation)**：
    *   当新进程创建时，OS 需要在物理内存中找一块足够大的**连续**空闲区域。
    *   *工具*：**空闲列表 (Free List)**。记录哪些内存没被人用。
2.  **内存回收 (Reclaim)**：
    *   当进程结束时，OS 将其占用的内存放回空闲列表，并清理相关数据结构。
3.  **上下文切换 (Context Switch)**：
    *   **关键动作**：
        *   当进程 A 停止时，OS 把它那一对 Base/Bounds 寄存器的值保存在 A 的 **PCB (进程控制块)** 中。
        *   当进程 B 开始时，OS 从 B 的 PCB 中读出数值，**重新加载**到 CPU 的 Base/Bounds 寄存器中。
    *   *只有当 OS 处于内核态时，才能执行这种特权指令。*
4.  **异常处理 (Exception Handling)**：
    *   当硬件报告“有人越界”时，OS 负责善后（通常是终止进程并报错）。

---

## 5. 局限性与伏笔 (The Problem)

虽然“基址+界限”简单高效，但它有两个致命缺点，这迫使我们寻找更好的方案（分段）：

1.  **内部碎片 (Internal Fragmentation)**：
    *   我们在笔记开头提到，每个进程都有“堆”和“栈”，中间有一大块空闲区域。
    *   在 Base+Bounds 模式下，OS 必须给进程分配一块**连续**的物理内存，这块连续内存必须大到能包住堆和栈。
    *   结果：堆栈中间那块巨大的空白区域，虽然没人用，但也占用了物理内存。这就是**内部碎片**（分配了但没用到）。

2.  **必须连续**：
    *   很难在物理内存中找到一大块连续的空间。这就像你想在电影院找 10 个连座很难，但找 10 个分散的空座很容易。

**➡️ 下一站：分段 (Segmentation)**
为了解决这两个问题，我们想出一个办法：**与其给整个地址空间只有一对基址/界限，不如给堆、栈、代码段各分配一对基址/界限？** 这样它们就能独立地散落在物理内存的不同位置了！