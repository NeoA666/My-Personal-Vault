# 🔱 Unix 进程核心 API：Fork, Exec 与 Wait
---
## 1. 概念总览 (The Big Three)

这三个系统调用构成了 Unix 世界中进程管理的“三位一体”。

### 🧬 `fork()`：分身术

- **作用**：当前进程克隆出一个子进程。
    - 子进程是父进程的**副本**：拥有几乎一样的内存内容、文件描述符、寄存器状态。
    - **重要机制：写时复制 (Copy-on-Write, COW)**。OS 不会傻傻地立刻复制所有物理内存，而是让父子共享同一份内存。只有当其中一方试图**修改**数据时，OS 才会瞬间复制那一页内存。这使得 `fork()` 极快。
- **返回值（分流的关键）**：
    - **父进程中**：返回子进程的 PID（>0）。（因为父进程需要知道孩子叫什么，好以后管它）。
    - **子进程中**：返回 0。（孩子知道自己是新生儿）。
    - **失败**：返回 -1。
- **比喻**：就像**细胞有丝分裂**。原本的一个细胞分裂成两个，两者基因（代码）完全相同，状态也同步，但它们是两个独立的生命体。

### 🧠 `exec()`：换脑术

- **作用**：用一个新的可执行程序“替换”当前进程的身体（内存空间）。
    - **PID 不变**：身份没变，但是“灵魂”（代码和数据）换了。
    - **彻底性**：原进程的代码段、数据段、堆栈统统被丢弃，换上新程序的。
- **返回值**：
    - **成功**：**永不返回**。因为原程序的代码已经被抹去了，没法返回。
    - **失败**：返回 -1（只有失败了，旧的灵魂才还在，才能报错）。
- **比喻**：就像**被附身**或**洗脑**。你（PID）还是你，但你的记忆和要做的事（代码）完全变成了另一个人（新程序）。

### ⚰️ `wait()` / `waitpid()`：收尸人

- **作用**：父进程暂停运行，“回收”已经退出的子进程，获取其“遗言”（退出状态码）。
    - **僵尸进程 (Zombie Process)**：如果子进程死了，父进程没调用 `wait()` 给它收尸，子进程的条目就会一直留在系统进程表中，变成“僵尸”。
- **区别**：
    - `wait()`：等任意一个孩子死。
    - `waitpid()`：等指定的某个孩子死（支持非阻塞选项 `WNOHANG`，即“看看死了没，没死我先忙别的”）。
- **比喻**：就像**家长接放学**。孩子（子进程）放学（退出）了，不能直接消失，必须等家长（父进程）签字领走（wait），才能真正回家。

---

## 2. 三者之间的协作流程

这是 Unix 运行新程序的标准范式：**先复制，再替换**。

1. **Fork**：父进程调用 `fork()`。
    - _此刻，两个进程同时存在，运行着相同的代码。_
2. **Branch**：通过返回值判断身份。
    - _父进程_：通常进入 `else` 分支，准备调用 `wait()`。
    - _子进程_：进入 `if (pid == 0)` 分支。
3. **Exec**：子进程调用 `exec()`。
    - _子进程的旧躯壳被新程序填充，开始执行新程序的 main 函数。_
4. **Wait**：父进程调用 `wait()`。
    - _父进程阻塞，直到子进程运行结束。_

### 🤔 深度思考：为什么不直接搞一个 `spawn()` 函数？

为什么要分开 `fork` 和 `exec` 两步走？

- **答案**：为了灵活性。
- 在 `fork` 之后但 `exec` 之前，子进程可以**微调自己的环境**，比如：
    - **I/O 重定向**：`ls > file.txt`（在 exec `ls` 之前，把标准输出指向文件）。
    - **管道**：`ls | grep`（连接输入输出）。
    - **改变用户 ID**。
- 这正是 Unix Shell 如此强大的核心原因。

---

## 3. 最小实例化代码 (Annotated)

这段代码展示了最标准的写法。注意看注释中的细节。

C

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(void) {
    printf("Parent (PID:%d) starting...\n", getpid());

    // 1. 分身：创建子进程
    pid_t pid = fork(); 
    
    if (pid < 0) {
        perror("fork failed"); // ⚠️ 易错点：永远要检查 fork 是否失败
        return 1;
    }

    if (pid == 0) {
        // ============ 子进程世界 ============
        printf("Child (PID:%d) running. Now changing brain...\n", getpid());
        
        // 2. 换脑：执行 ls -l
        // ⚠️ 注意：execvp 需要一个以 NULL 结尾的数组
        char *argv[] = { "ls", "-l", NULL };
        
        execvp(argv[0], argv); 
        
        // ⚠️ 重点：如果代码走到这里，说明 execvp 失败了！
        // 因为如果成功，进程的内存已经被 ls 替换了，根本不会执行这一行。
        perror("execvp failed");       
        _exit(127); // 使用 _exit 退出子进程更安全
    } else {
        // ============ 父进程世界 ============
        printf("Parent waiting for child (PID:%d)...\n", pid);
        
        // 3. 收尸：等待子进程结束
        int status = 0;
        pid_t w = waitpid(pid, &status, 0); // 0 表示阻塞等待
        
        if (w == -1) {
            perror("waitpid failed");
            return 1;
        }

        // 解析子进程是怎么死的
        if (WIFEXITED(status)) {
            printf("Child exited normally with code %d\n", WEXITSTATUS(status));
        } else if (WIFSIGNALED(status)) {
            printf("Child was killed by signal %d\n", WTERMSIG(status));
        }
    }
    return 0;
}
```

---

## 4. 其他 API 与工具

- **`kill()`**：不要被名字骗了，它本质是**发送信号 (Signal)**。
    - 可以发 `SIGKILL` (9) 杀死进程。
    - 也可以发 `SIGSTOP` / `SIGCONT` 让进程暂停或继续。
    - 甚至可以发 `SIGINT` (相当于 Ctrl+C)。
- **命令行工具**：
    - `ps`：查看进程快照。
    - `top` / `htop`：实时查看进程。
    - `kill`：在终端发送信号。
    - **Man 手册**：遇到不懂的系统调用，请熟练使用 `man 2 fork`, `man 2 execve`。

---

## 🎓 总结

- **Fork** 是“细胞分裂”，制造分身，利用 COW 技术实现高效复制。
- **Exec** 是“灵魂附体”，借用旧的躯壳（PID）运行新的代码。
- **Wait** 是“入土为安”，防止僵尸进程占用系统资源。
- **设计哲学**：将创建（fork）与执行（exec）解耦，赋予了程序员（特别是 Shell 开发者）在中间夹层进行**环境配置（如重定向）**的巨大权力。这就是 Unix 的简洁与强大之处。