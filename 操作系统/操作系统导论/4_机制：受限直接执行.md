
操作系统通过一些低级机制和高级策略实现CPU虚拟化

虚拟化机制要求：保持控制权的同时获得高性能

## 受限直接执行

**用于解决如何让程序不做任何我们不希望它做的事以及高效运行它**

- 将处理器模式分为两种：用户模式和内核模式，并采用受保护的控制权转移实现权限保护，且两者的模式转移要通过陷阱指令
- 通过陷阱表保证进入内核态执行的代码不会跳转到任意位置而是到达指定位置执行



| 内核模式                                                        | 硬件                            | 程序            |
| ----------------------------------------------------------- | ----------------------------- | ------------- |
| 加载与准备：装入单个程序；建立用户栈和内核栈；设置初始寄存器（入口地址、栈指针）；建立陷阱表并注册处理入口       | 接收陷阱表基址；准备内存与设备               |               |
| 设置内存与权限：按需建立地址规则（如代码只读、数据可写）；写入相关基址；准备初始返回现场                |                               |               |
| 通过陷阱返回进入用户态：将必要的内核寄存器保存在内核栈；设置用户态的入口地址与栈指针；执行“从陷阱返回”指令切到用户态 | 完成特权级切换到用户态                   | 从入口开始执行       |
| 正常运行（用户态）                                                   | 取指并执行；按规则访问内存                 | 执行指令，读写内存/文件  |
| 发起系统调用（用户态→内核态，经陷阱）                                         | 执行陷阱指令/异常，自动把返回地址与状态压入栈并切到内核态 | 执行系统调用指令并等待   |
| 陷阱入口现场保护：保存用户寄存器到内核栈，记录返回位置                                 | 维持内核态执行                       | 暂停，等待内核完成     |
| 处理请求：执行文件/设备/内存等操作，必要时等待设备完成                                | 驱动设备或等待中断完成                   | 若需等待则暂时不运行    |
| 中断/异常（任一态→内核态，经陷阱）                                          | 自动保存最小现场并切到内核态                | 暂停，等待处理中断/异常  |
| 从陷阱返回用户态：根据内核栈中的记录恢复用户寄存器与用户栈；执行“从陷阱返回”，回到触发点后继续            | 恢复PC与状态，切回用户态                 | 从系统调用/中断返回点继续 |
| 程序结束：通过系统调用请求退出，释放内存等资源                                     | 清理相关状态                        | 结束运行          |

## 在进程之间切换

关键问题：**如何重获CPU控制权**

### 协作方式：等待系统调用

OS通过等待系统调用（进程发出，一般是I/O操作），或者进程发生非法操作（如访问无法访问的内存等），实现控制权的拿回

### 非协作方式：操作系统进行控制

**利用时钟中断实现重新获取控制权**，通过同时启动时钟设备，利用在操作系统中预先配置的中断处理程序实现CPU控制权的获取，一般为几毫秒一次

#### 保存和恢复上下文

当**调度程序**决定切换进程时，OS会执行一些底层代码，实现上下文的保存和切换。

具体流程：时钟中断，将寄存器（A）保存到内核栈（A），转换为内核模式 ——> 内核处理陷阱，调用switch（）例程，将寄存器（A）保存到进程结构（A），同时将进程结构（B）保存到寄存器（B） ——> 从内核栈（B）恢复到寄存器（B），转向用户模式，处理进程B

- 硬件操作：
	- 记住系统调用处理程序和是时钟处理程序地址
	- 启动时钟，实现时钟中断
	- 数据读取与存储

并发问题：系统调用时中断？中断中中断？ Locking操作