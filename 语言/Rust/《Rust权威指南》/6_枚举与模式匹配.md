# 🚦 第六章：枚举与模式匹配

## 1. 枚举 (Enums)：不仅是列表

在 Rust 中，枚举不仅仅是一组命名的常量，它还可以**携带数据**。

### 🌟 超级枚举

- **灵活**：每个变体 (Variant) 可以包含不同类型、不同数量的数据。
- **方法**：就像结构体一样，你也可以用 `impl` 给枚举定义方法。

Rust

```
enum Message {
    Quit,                       // 没有关联数据
    Move { x: i32, y: i32 },    // 包含一个匿名结构体
    Write(String),              // 包含一个 String
    ChangeColor(i32, i32, i32), // 包含三个 i32
}

impl Message {
    fn call(&self) {
        // 在这里定义方法体
    }
}
```

---

## 2. `Option<T>`：十亿美元错误的终结者

Rust 没有 `Null`。取而代之的是标准库中的 `Option<T>` 枚举。这可以说是 Rust 安全性的核心支柱之一。

### 📦 定义

Rust

```
enum Option<T> {
    Some(T), // 有值，里面包着一个 T 类型的数据
    None,    // 没值，类似于 null
}
```

- **预导入 (Prelude)**：你不需要写 `Option::Some`，直接写 `Some(5)` 或 `None` 即可。

### 🛡️ 为什么比 Null 安全？

在 Java 或 C++ 中，`String s = null` 和 `String s = "hello"` 类型是一样的，你随时可能忘记检查 null 而导致崩溃。

在 Rust 中：

- `String`：**保证**一定有值，不可能是空的。你可以放心大胆地用。
- `Option<String>`：**可能**是空的。如果你想把它当 String 用，编译器**强制**你先处理 `None` 的情况（比如解包）。

> **总结**：`Option` 迫使你在代码层面显式地处理“空值”情况，从而在编译期杜绝了 Null Pointer Exception。

---

## 3. `match` 控制流：强大的模式匹配

`match` 就像是 C 语言 `switch` 的超级进化版。

### 🔍 核心机制

- **穷尽性 (Exhaustiveness)**：**这是最重要的特性**。Rust 强制你处理所有可能的情况。如果漏掉了一个，代码就编译不过。这能避免无数逻辑 Bug。
- **绑定数据**：匹配的同时，可以把枚举变体里携带的数据拆解（解构）出来使用。

Rust

```
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState), // Quarter 变体里藏着一个 UsState 枚举
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        // 模式绑定：把 Quarter 里的 state 拿出来用
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```

### 🃏 通配符与占位符

如果你不想处理所有情况，或者剩下的情况处理逻辑都一样：

- **`_` (通配符)**：匹配所有未列出的值。
- **`()` (单元值)**：什么都不做。

Rust

```
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => (), // 摇到其他数字，啥也不干，这行必须加，否则报错
}
```

---

## 4. `if let`：简洁的语法糖

当你**只关心一种情况**，而不想写那个烦人的 `_ => ()` 时，用 `if let`。

Rust

```
let config_max = Some(3u8);

// 繁琐写法
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max),
    _ => (),
}

// 简洁写法 (if let)
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
} else {
    // 也可以加 else 处理 None 的情况
}
```

- **代价**：失去了 `match` 的穷尽性检查。你需要自己权衡是想要简洁还是想要编译器的严格检查。

---

## 🎓 总结

- **枚举**：在 Rust 中非常强大，可以携带数据。
- **Option**：用类型系统取代了 `Null`，强制程序员处理空值，极大提升了安全性。
- **Match**：逻辑分支的守护神，它的穷尽性检查能帮你兜底。
- **if let**：当你只想处理匹配中的“独苗”时的快捷方式。