## 枚举

**枚举**是一种自定义数据类型，用关键词`enum`来定义，并列举了一些内容，这些内容叫**枚举变体**

枚举允许我们直接将相关联的数据嵌入到枚举变体中，且每个变体可以拥有不同类型和数量的关联数据，还可以利用`impl`关键词实现对枚举的方法定义

```Rust
enum IpAddr{
	V4(u8,u8,u8,u8),
	V6(String),
}

let home = IpAddr::V4(127,0,0,1);

let loopback = IpAddr::V6(String::from("::1"));
```


### Option枚举

```Rust
enum Option<T> {
	Some(T),
	None,
}
```

`Option`被包含在预导入模块中，我们不需要显式将其引入作用域，可以在不加前缀的情况下使用；`<T>`是一个泛型参数，在这里表示Option的Some变体可以包含任意类型的数据；`Opyion<T>`与T不是一种类型；

通过利用`Option<T>`，我们可以减少空值泛滥的情况，因为当我们要持有一个为空的值，我们必须显式地利用Option::None`来表示，这样当我们想要非法操作一个为空的值时，编译器会阻止我们这么做

总结：`Option::None`是一种空值，他的含义与NULL相似，但他不是物理内存意义上的空

### Option枚举

`match`运算符允许一个值与一系列的模式相匹配并执行相应的代码，代码同时也是一个表达式，其结果会作为match表达式的结果返回；同时也可以为匹配变体绑定相关联的数据

Rust的匹配时穷尽的，当没有穷尽匹配选项时则不能通过编译，当我们只关心几个特殊的匹配时，我们可以利用通配符`_`来完成，例：`_ => ()`

当我们只关心一种情况的情形下，我们可以使用if let和else来匹配