# 🦀 Rust 学习笔记：闭包与迭代器

> **核心思想**：Rust 的函数式编程特性允许我们将函数作为参数值、返回值，或者将其赋值给变量。这种灵活的设计不仅提高了代码的复用性，还在编译器强大的优化下保持了极高的执行效率。

---

## 🟢 第一部分：闭包 (Closures)

闭包（Closures）是可以保存在变量中或作为参数传递给其他函数的**匿名函数**。

### 1.1 闭包：能够捕获环境的匿名函数

普通函数（使用 `fn` 定义）就像是放在工具箱里的工具，它们是孤立的，看不见外部作用域的变量。而**闭包**就像是你随身携带的背包，它不仅包含逻辑（工具），还能随时访问你背包里装的东西（当前作用域的变量）。

**基本语法对比：**

Rust

```
fn  add_one_v1   (x: u32) -> u32 { x + 1 }  // 普通函数
let add_one_v2 = |x: u32| -> u32 { x + 1 }; // 完整语法的闭包
let add_one_v3 = |x|             x + 1;     // 省略类型和花括号的闭包
```

### 1.2 使用闭包来创建抽象化的程序行为

闭包常用于当你需要将一段“稍后执行”的代码传递给某个流程时。

**生活中的比喻**： 想象你在定制一件T恤。

- **普通函数**：你直接给工厂一张做好的设计图。
- **闭包**：你给工厂一个设计师（闭包），告诉工厂：“当你们找到红布料的时候（触发条件），让这个设计师根据布料的大小（参数）现场画一个图案。”

### 1.3 闭包的类型推断和类型标注

Rust 编译器非常聪明。普通函数必须标注类型，是因为它们是提供给外部使用的 API，需要明确契约。而闭包通常短小且只在当前上下文使用，编译器可以根据你第一次调用它的方式推断出类型。

**⚠️ 易错点（类型锁定）：** 一旦闭包的参数类型被推断确定（例如第一次调用传入了 `String`），你就不能再传 `u32` 给它了。

Rust

```
let example_closure = |x| x;

let s = example_closure(String::from("hello")); // 编译器推断 x 是 String
// let n = example_closure(5); // ❌ 报错！编译器已经认定 x 必须是 String
```

### 1.4 使用泛型参数和 Fn trait 来存储闭包

如果我们想把闭包存到一个 Struct 结构体里，必须明确闭包的类型。因为闭包是匿名的，我们需要使用 **Trait Bound（特征约束）** 和 **泛型**。

Rust 提供了三个 Fn Trait 来描述闭包：

1. **`Fn`**：闭包不可变地借用环境中的值。
2. **`FnMut`**：闭包可变地借用环境中的值（会修改环境）。
3. **`FnOnce`**：闭包获取环境中值的所有权（只能被调用一次）。

**代码实例：**

Rust

```
struct Cacher<T>
where
    T: Fn(u32) -> u32, // T 必须是一个闭包，参数 u32，返回 u32
{
    calculation: T,
    value: Option<u32>,
}
```

### 1.5 Cacher 实现的局限性

书中的 `Cacher` 例子是为了演示“记忆化（Memoization）”或“延迟计算（Lazy Evaluation）”。它的逻辑是：如果算过一次，就存起来，下次直接给值；没算过就调用闭包算一次。

**书中的简易实现存在两个主要局限性：**

1. **不管传入什么参数，只返回第一次计算的结果**：如果第一次调用 `arg: 1`，它缓存了结果。第二次调用 `arg: 2`，它依然返回 `arg: 1` 的缓存结果。
    - _解决方案_：应该使用 `HashMap` 来存储 `(arg, result)` 的键值对。
2. **类型限制**：目前的实现写死了 `u32`。
    - _解决方案_：使用更多的泛型参数来替代硬编码的 `u32`。

### 1.6 使用闭包捕获上下文环境

这是闭包最强大的地方。普通函数不能读取定义它的块级作用域里的变量，但闭包可以。

**三种捕获方式（对应三个 Fn Trait）：**

1. **借用** (`Fn`)：只读。
2. **可变借用** (`FnMut`)：读取并修改。
3. **获取所有权** (`FnOnce`)：拿走变量，导致原变量失效。通常通过 `move` 关键字强制实现。

**`move` 关键字实例：** 当你想把闭包从一个线程移到另一个线程，或者让闭包活得比当前作用域更久时，必须使用 `move`。

Rust

```
fn main() {
    let x = vec![1, 2, 3];
    
    // 使用 move 强制闭包获取 x 的所有权
    let equal_to_x = move |z| z == x; 

    // println!("can't use x here: {:?}", x); // ❌ 报错！x 的所有权已经被闭包拿走了
    
    let y = vec![1, 2, 3];
    assert!(equal_to_x(y));
}
```

---

## 🟡 第二部分：使用迭代器处理元素序列

迭代器模式允许你对一个序列中的项进行处理。

### 2.1 Iterator trait 和 next 方法

迭代器的核心在于 **惰性（Lazy）**。 **比喻**：创建一个迭代器就像是接好了水管和水龙头，但在你真正拧开水龙头（调用消费方法）之前，水（逻辑）是不会流动的。

所有迭代器都实现了 `Iterator` trait，其核心是 `next` 方法：

Rust

```
pub trait Iterator {
    type Item; // 关联类型
    fn next(&mut self) -> Option<Self::Item>; // 返回 Option，也就是 Some(Item) 或 None
}
```

### 2.2 消耗迭代器的方法 (Consuming Adaptors)

这些方法会调用 `next`，直到迭代器返回 `None`。因为它们“用尽”了迭代器，所以被称为消耗型适配器。

- `sum()`: 求和。
- `collect()`: 将迭代结果收集到集合中（最常用）。
- `for` 循环: 隐式地消耗迭代器。

### 2.3 生成其他迭代器的方法 (Iterator Adaptors)

这些方法不会消耗迭代器，而是通过改变原有迭代器的属性，**生成一个新的迭代器**。这是链式调用的基础。

- `map()`: 对每个元素进行转换。
- `filter()`: 过滤元素。

**💡 重点提示：** 因为迭代器是惰性的，如果你只写了 `map` 而不写 `collect` 或其他消耗方法，编译器会警告你：“这行代码什么都没做”。

Rust

```
let v1: Vec<i32> = vec![1, 2, 3];
// 必须在最后调用 collect()，否则 map 根本不会执行
let v2: Vec<_> = v1.iter().map(|x| x + 1).collect(); 
```

### 2.4 使用闭包捕获环境（在迭代器中）

迭代器的适配器（如 `filter`）通常接受一个闭包作为参数。这个闭包可以捕获外部变量，从而实现强大的筛选逻辑。

**场景**：你要在一个鞋子集合中，筛选出符合你自己鞋码的鞋子。

Rust

```
#[derive(PartialEq, Debug)]
struct Shoe { size: u32, style: String }

fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter()
        // 这里闭包捕获了函数的参数 shoe_size
        .filter(|s| s.size == shoe_size) 
        .collect()
}
```

### 2.5 使用 Iterator trait 创建自定义迭代器

虽然你可以通过 `Vec` 获得迭代器，但有时你需要自己实现逻辑。只需要定义一个 Struct，并为它实现 `Iterator` trait（主要是定义 `next` 方法）。

**实例：从 1 数到 5 的计数器**

Rust

```
struct Counter { count: u32 }

impl Counter {
    fn new() -> Counter { Counter { count: 0 } }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None // 返回 None 告知迭代结束
        }
    }
}
```

---

## 🔵 第三部分：比较循环和迭代器的性能

这是很多新手最担心的问题：“为了写得优雅用迭代器，会不会导致程序变慢？”

### 结论：迭代器甚至比手写的循环更快！

Rust 的迭代器是 **零成本抽象 (Zero-Cost Abstractions)** 之一。这意味着你可以使用高级的抽象概念，而不用担心运行时产生额外的性能开销。

### 为什么这么快？

1. **循环展开 (Unrolling)**：编译器非常聪明，它会将迭代器的链式调用优化成极其底层的汇编代码，甚至消除了循环控制的开销。
2. **没有边界检查**：在普通的 `for` 索引循环中（如 `arr[i]`），编译器可能需要进行边界检查。而迭代器在内部保证了访问的安全性，编译器可以优化掉这些检查。

**引用：** Bjarne Stroustrup（C++之父）对零成本抽象的定义非常适合这里：

> "What you don’t use, you don’t pay for. And further: what you do use, you couldn’t hand code any better." (你没用到的东西，不需要为之付出代价；你用到的东西，你自己手写代码也不可能做得更好。)

---

## 📝 总结 (Summary)

1. **闭包 (Closures)** 是 Rust 处理“传递行为”的现代化工具。它比函数指针更强大，因为它能捕获环境（背包隐喻）。但要小心所有权转移（`move`）和类型锁定的问题。
2. **迭代器 (Iterators)** 是 Rust 处理序列的核心。记住它具有**惰性**（不拧水龙头不出水）。通过组合 `map`, `filter` 和 `collect`，我们可以写出极其清晰且表达力强的代码。
3. **性能无忧**：不要因为担心性能而回避使用闭包和迭代器。在 Rust 中，通常情况下，抽象程度越高的代码，经过编译器优化后的运行效率反而越高（或持平）。

---