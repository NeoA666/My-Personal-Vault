
```Rust```使用含有特定规则的所有权系统管理内存，允许编译器检查工作，且不产生额外开销

栈，“后进先出”，其中的元素都必须有一个已知的固定大小；而堆的内存空间管理较为松散，可以从堆中申请一块足够大的可用空间。由于指针的大小是固定的，因此可以将指针存在栈中，便于地址访问

## 所有权规则

- 每一个值都有一个对应变量作为它的所有者

- 在同一时间中，值有且仅有一个所有者

- 当所有者离开自己的作用域时，它持有的值就会被释放

### String类型

是一个存储于堆上的数据类型，可以用于接收不同大小的字符串类型

字符串字面量是不可变的，硬编码进程序（直接嵌入到最终的可执行文件中），通过利用String类型下的from函数我们可以将一个字符串字面量转化为可变的String类型

## 内存与分配

为了支持一个可变的，可增长的文本数据类型，操作系统需要动态分配一块在堆上内存给String类型，且在完成后要用某种方式对内存进行释放

内存回收方式：
- 有垃圾回收（GC）机制的语言中，GC自动记录并清除
- 无GC机制的语言中，需要程序员自己调用代码显式地释放内存
- Rust语言在变量**离开作用域**（即 } 处）时自动调用drop函数释放内存代码

### 内存与数据交互的方式

#### 移动

```Rust
let s1 = String::from("Hello");

let s2 = s1;
```

一个String类型的三部分组成，第一部分一个指向存放字符串内容的指针，一个长度值和一个容量值，这三部分是在栈上存储的，字符串内容是在堆上存储的（见《Rust权威指南》P87）

Rust在复制String类型变量时使用浅度拷贝策略，因此这里的s2是拥有一个相同的指向堆上的字符串指针。同时为了避免内存二次释放，Rust会简单地废弃s1。

**Rust永远不会自动创建数据的深度拷贝。因此在Rust中，任何自动的赋值操作都可视为高效的**

### 克隆

当确实需要去深度拷贝储存在堆上的数据时，我们可以调用clone方法实现对堆上的数据进行复制

#### 栈上数据的复制

拥有了Copy的trait的变量，可以在赋值给其他变量后保持原变量的可用性
- 所有整数类型，浮点数类型，字符类型
- 布尔类型
- 元组中的所有字段都是可Copy的，那么就说这个元组也是可Cpoy的

这些类型都可以在编译时确定大小并将数据完整地存储在栈中，进行复制操作都是高效的

## 所有权与函数

```Rust
fn main(){
	let s = String::from("hello");
	
	take_ownership(s);//s开始不再有效
	
	let x = 5;
	
	make_copy(x);//由于i32是可Copy的，x仍然有效
}
```

变量所有权转移模式：
	将一个值赋给另一个值的时候会转移所有权；当一个持有堆数据的变量离开作用域时，他的数据就会被drop清理回收，除非这些数据的所遇权移动到另一个变量上

那么我们如何保留非Copy类变量的可用性呢？ -> 引用和借用

## 引用和借用

`&`表示引用语意，可以在不获取所有权的前提下使用值

`*`解引用，与`&`相反的操作

通过引用传递参数给函数的方式被称为**借用**

借用情况下，没有目标值的所有权，无法进行非法的修改

### 可变引用

通过使用`&mut 变量名`实现可变引用的声明

编译器在编译时通过借用检查器（borrow checker）强制“别名与可变性互斥”（aliasing XOR mutability）的规则：任意时刻要么有任意多个不可变引用（&T），要么有且只有一个可变引用（&mut T）。这样可以在编译期排除数据竞争（data race）。

### 悬垂引用

**悬垂指针**概念：这类指针指向某处内存地址空间，但该内存空间已经被释放掉或者重新分配了

编译器可以确保一个数据不会在引用被销毁前离开自己的作用域，实际上就是利用自己的所有权规则

### 总结
- 在任意一段时间内，要么只能有一个可变引用，要么有任意数量的不可变引用

- 引用总是有效的

### 切片

另一种**不持有所有权的数据类型**

字符串切片使用案例：`[0..2];[..2];[2..];[..]`

字符串字面量就是切片，不用使用切片语法，而使用String类型时要使用切片语法

