# 🛡️ 第三章：所有权 (Ownership) —— Rust 的灵魂

## 1. 内存管理的三国演义

在计算机世界，管理内存通常只有三种流派：

1. **垃圾回收 (GC) 派**（Java, Python）：有专门的清洁工（GC线程）跟在你后面扫地。
    - _优点_：省心。 _缺点_：有运行时开销，偶尔卡顿。
2. **手动管理派**（C, C++）：你自己分配，你自己释放。
    - _优点_：极快。 _缺点_：容易忘（内存泄漏）或释放两次（崩溃），心智负担极重。
3. **所有权派**（Rust）：**通过编译时规则自动管理**。
    - _特点_：不需要 GC，也不需要手写 `free`。编译器在编译阶段就插入了释放代码。**零成本抽象，既安全又快**。

---

## 2. 栈 (Stack) 与 堆 (Heap) 的基础

理解所有权必须先理解内存结构：

- **栈**：后进先出，紧凑高效。存**固定大小**的数据（如 `i32`, 指针）。
- **堆**：杂乱无章，空间巨大。存**大小未知或可变**的数据（如 `String` 内容）。
- _比喻_：栈就像去餐馆吃饭，大家紧挨着坐；堆就像去广场找空地野餐，需要先找管理员申请一块够大的地皮，拿到坐标（指针）才能去。

---

## 3. 所有权三原则 (The Rules)

请把这三句话刻在脑子里：

1. **每个值都有一个变量作为它的所有者 (Owner)。**
2. **同一时间，只能有一个所有者。**
3. **当所有者离开作用域 (Scope)，值就会被丢弃 (Drop)。**

---

## 4. String 类型与内存布局

`String` 是理解堆内存管理的最佳案例。

### 移动 (Move) 语义

Rust

```
let s1 = String::from("Hello");
let s2 = s1; 
// 🚫 此时再使用 s1 会报错：value borrowed here after move
```

**内存发生了什么？** `String` 在内存中由两部分组成：

1. **栈上数据**：包含 `ptr`（指向堆的指针）、`len`（长度）、`capacity`（容量）。
2. **堆上数据**：实际的字符内容 `"Hello"`。

当 `let s2 = s1` 时：

- **浅拷贝 (Shallow Copy)**：Rust 只复制了栈上的那 3 个字段。堆上的 `"Hello"` **没有**被复制。
- **所有权转移**：为了避免“二次释放”（Double Free，即 s1 和 s2 离开作用域时都尝试释放同一块堆内存），Rust 规定 **s1 失效了**。
- 这不叫浅拷贝，Rust 称之为 **移动 (Move)**。

### 克隆 (Clone)

如果你真的想把堆上的数据也复制一份（深度拷贝）：

Rust

```
let s2 = s1.clone(); 
// ✅ 此时 s1 和 s2 都有效，堆上有两个 "Hello"
```

### 栈上数据的复制 (Copy Trait)

为什么 `let x = 5; let y = x;` 后 `x` 还能用？

- 因为整数完全存储在栈上，复制非常快。
- Rust 给这些类型标注了 `Copy` 特征。
- **哪些是 Copy 的？**：标量类型（整数、浮点、布尔、字符）以及全由 Copy 类型组成的元组。

---

## 5. 引用与借用 (References and Borrowing)

如果每次传参给函数都要转移所有权，那太麻烦了。于是有了**引用**。

- **引用 (`&`)**：像指针，指向数据，但**不拥有**它。
- **借用**：创建引用的行为。

### ⚠️ 借用的铁律 (The Borrow Checker)

Rust 编译器里住着一个严格的管理员叫“借用检查器”。它强制执行以下规则，**旨在编译期彻底消灭数据竞争 (Data Race)**：

> **规则：在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。** _(The Aliasing XOR Mutability Rule)_

1. **不可变引用 (`&T`)**：也就是**只读**引用。
    - 你可以有无数个。大家都只是看看，不会出事。
2. **可变引用 (`&mut T`)**：也就是**读写**引用。
    - **独占性**：一旦你借了一个可变引用，同一作用域内就不能再有别的引用（哪怕是不可变的也不行）。

Rust

```
let mut s = String::from("hello");

let r1 = &s; // ✅
let r2 = &s; // ✅
// let r3 = &mut s; // ❌ 报错！不能在拥有不可变引用的同时创建可变引用
// println!("{}, {}, and {}", r1, r2, r3);
```

- **为什么？** 如果 `r1` 正在读，`r3` 突然把数据改了甚至释放了，`r1` 就会读到垃圾数据或崩溃。

### 悬垂引用 (Dangling Reference)

C++ 中容易出现“指针指向了一个已经被释放的内存”。Rust 编译器保证**引用永远有效**。 如果数据比引用先销毁，编译直接不通过。

---

## 6. 切片 (Slices)

切片是另一种**不持有所有权**的数据类型。它允许你引用集合中一段连续的元素。

### 字符串切片 (`&str`)

Rust

```
let s = String::from("hello world");
let hello = &s[0..5]; // hello 是一个切片
```

- **内存结构**：切片在栈上存了两个东西：
    1. 指向切片起点的**指针**。
    2. 切片的**长度**。
- **String 字面量**：`let s = "Hello";` 这里的 `s` 类型就是 `&str`。它是一个指向二进制可执行文件中特定位置的切片。

---

## 🎓 总结

- **所有权**：是 Rust 内存安全的基石。变量离开作用域自动 Drop。
- **Move**：赋值默认是移动（除非实现了 Copy），防止二次释放。
- **引用**：借用数据而不获取所有权。
- **借用规则**：**写独占，读共享**。这个规则虽然让新手很痛苦，但它在编译阶段就扼杀了并发 Bug。

这一章是 Rust 最难翻越的大山之一。一旦理解了所有权，你就掌握了“Rust 之道”的核心。下一章我们将学习如何用结构体来组织数据！🏗️