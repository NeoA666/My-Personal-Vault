## 变量与可变性

### 变量的不可变性
Rust的变量是默认不可变的，并通过let进行初始化赋值，通过添加mut关键词使变量可变
```Rust
fn main(){
    let x = 5;
    x=6;
}

fn main(){
    let mut x = 5;
    x=6;
}
//仅下面这段代码能够通过编译
```

### 变量与常量

利用const关键词实现对于常量的声明，它是总是不可变的，并以下划线分隔的全大写字母来命名一个常量

### 隐藏

通过使用let关键词我们可以对一个值实现变换操作，如自加自减，类型改变。这些都可以通过一个变量名实现
```Rust
fn main(){
	let x = 5;
	let x = x + 1;
	
	let space = "    ";
	let space = space.len();
}
```


## 数据类型

Rust是一门静态语言类型    静态语言说明：[[静态类型语言的特点与优缺点]] ^91a308

### 标量类型

#### 整数类型

大体上分为两种类型，一种为有符号类型，另一种是无符号类型。例：i8，u8，i64。后面的数字为字节长度

还有isize和usize两种特殊的整数类型，长度决定于运行的目标平台。

类型还可以通过后缀表明；大的整数可以用下划线分隔方便阅读

32位的整数类型为默认推导类型，大部分情况下它都是运行最快的那一个

整数溢出报错：panic！
**Panic**用于描述程序因错误而退出的情况

以release形式编译的Rust程序，出现整数溢出时，编译器会选择进行循环“环绕”，如u8类型赋值256会循环为0；如果希望显示环绕，使用类型Wrapping

#### 浮点数类型

提供了两种类型，分别为f32和f64，分别对应着单精度浮点数和双精度浮点数

#### 数值运算

没啥好记的

#### 布尔类型

没啥好记的

#### 字符类型

没啥好记的

### 复合类型

#### 元组类型

- 特点
	可以含有多个不同类型的变量
	拥有一个固定的长度

##### 元组的读取

- 模式匹配**解构**
```Rust
fn main(){
	let tup = (500, 6.4, 1);
	
	let (x, y, z) = tup;
}
```

- 点号访问
```Rust
fn main*(){
	let tup = (500, 6.4, 1);
	
	let five_hundred = tup.0;
}
```

#### 数组类型

- 特点
	只能有一个类型的变量
	拥有一个固定的长度

数组的定义与赋值
```Rust
fn main(){
	let a: [i32; 5] = [1, 2, 3, 4, 5];    //注意类型声明与数量声明之间是分号
	
	let a = [3;5];    //用于生成五个相同的元素填入数组中
}
```

利用数组索引访问数组元素

Rust在每次通过索引来访问一个元素时，会检查索引值是否小于当前数组长度，超出数组长度就会出现panic，**这样的设计不会像C一样访问到一些无效的内存空间**

## 函数

fn关键字用于声明性函数

Rust代码使用蛇形命名法，用小写的字母和下划线对变量和函数进行命名

**Rust不关心你在何处定义函数**

在函数签名中，你必须**显式地声明每个参数的类型**

### 函数中的语句和表达式

- 语句：没有返回值
- 表达式：会计算出一个值作为结果    例：5；x+1    **可以没有；**

函数可以向调用他的代码返回值，但需要使用箭头符号  ->  来声明类型

可以使用return来返回一个特定的值，但函数会隐式地返回最后的表达式
```Rust
fn main(){
	let x = plus_one(5);
	
	println!("The value of x is: {}",x);

}

fn plus_one(x: i32) -> i32{
	x+1    //一定不能添加分号
}
```

## 注释

与C语言一致

## 控制流

### if表达式

必须显式地提供一个布尔类型给if语句，**Rust不会自动尝试将非布尔类型转换为布尔类型**

通过```elesif```实现多重判断并且仅执行第一个条件为真的代码块

### loop循环

相当于无限循环，可以利用```Ctrl+C```来终止这种陷入无限循环的程序

利用```break```关键词来程序退出循环

```Rust
fn main(){
	let result = loop{
		//利用if判断实现loop循环退出
	}
}
```

### while循环

### for循环

Rust编译器会检查数组的索引是否有越界情况，若有越界访问的问题，会停止输出

利用```Range```实现指定循环次数