# 🚨 第九章：错误处理 (Error Handling)

Rust 将错误分为两类：
1.  **不可恢复错误 (Unrecoverable Errors)**：Bug。如访问数组越界。直接崩溃。
2.  **可恢复错误 (Recoverable Errors)**：意外情况。如文件没找到。应该报告并处理。

## 1. 不可恢复错误：`panic!`

当程序遇到绝对无法继续运行的状态时，会调用 `panic!`。

### 💥 发生了什么？
默认情况下，Rust 会执行 **栈展开 (Stack Unwinding)**：
*   沿着调用栈往回走，清理每个函数的局部变量（运行 `drop`）。
*   最后退出程序。
*   *优化*：如果你想要二进制文件更小，可以在 `Cargo.toml` 中设置 `panic = 'abort'`，直接结束不清理（让操作系统去收尸）。

### 🕵️ 侦探工具：Backtrace
当程序 Panic 时，如果你想知道是从哪一行挂掉的：
*   **设置环境变量**：`RUST_BACKTRACE=1` 或 `RUST_BACKTRACE=full`。
*   **运行**：`cargo run`。
*   *前提*：不要用 `--release`，因为优化后的代码可能没有调试符号。

---

## 2. 可恢复错误：`Result<T, E>`

这是 Rust 错误处理的核心。它是一个枚举：
```rust
enum Result<T, E> {
    Ok(T),  // 成功，包含结果
    Err(E), // 失败，包含错误信息
}
```

### 🛠️ 匹配错误 (Matching Errors)
你可以像剥洋葱一样用 `match` 处理不同类型的错误。

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            // 文件没找到？那就创建一个！
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            // 其他错误（如没权限）？直接挂。
            other_error => panic!("Problem opening the file: {:?}", other_error),
        },
    };
}
```
> **闭包优化**：上面的嵌套 `match` 有点丑。实际开发中常用 `unwrap_or_else` 配合闭包来简化。

### ⚡ 快捷方式：Unwrap 与 Expect
如果你不想处理错误，或者你确信这里不会出错：
1.  **`unwrap()`**：
    *   如果是 Ok，返回里面的值。
    *   如果是 Err，**直接调用 panic!**。
2.  **`expect("自定义错误信息")`**：
    *   功能同上，但在 panic 时会打印你写的那句话。
    *   *推荐*：总是优先使用 `expect`，这相当于给未来的调试者留线索。

---

## 3. 传播错误 (Propagating Errors)

大多数时候，函数自己处理不了错误，需要把锅甩给调用者。

### 🚀 问号运算符 (`?`)
这是一个极度舒适的语法糖。

```rust
use std::fs::File;
use std::io;
use std::io::Read;

// 函数返回值必须是 Result
fn read_username_from_file() -> Result<String, io::Error> {
    // 写法 1：繁琐的 match
    /*
    let f = File::open("hello.txt");
    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e), // 提前返回错误
    };
    ...
    */

    // 写法 2：神奇的 ?
    let mut s = String::new();
    
    // 这一行做了三件事：
    // 1. 尝试打开文件。
    // 2. 如果成功，把 File 给 f。
    // 3. 如果失败，立刻 return Err(e)，结束整个函数。
    File::open("hello.txt")?.read_to_string(&mut s)?;
    
    Ok(s)
}
```

### ❓ 的隐式类型转换
*   `?` 运算符会自动调用 `from` 函数，将这里的错误类型转换为函数签名中定义的错误类型（`E`）。
*   这让你可以在一个函数里混合处理 IO 错误、网络错误等，只要它们都能转成统一的返回错误类型。

---

## 4. 什么时候该 Panic？

### ✅ 应该 Panic 的情况：
1.  **示例代码/原型代码**：用 `unwrap` 快速写完，以后再改。
2.  **不可恢复的逻辑错误**：比如你的代码逻辑保证了某个索引一定有效，但 Result 还是返回了 Err，这说明你的代码有 Bug。
3.  **契约被破坏**：调用者传入了无意义的参数（且无法用类型系统规避）。

### ❌ 不该 Panic 的情况：
1.  **库代码**：如果你写一个库给别人用，**永远不要 panic**。总是把 Result 返回去，让用户决定是重试还是崩溃。
2.  **可能失败的操作**：解析格式错误的 JSON、文件不存在、网络超时。这些都是常态，用 Result。

---

## 🎓 总结

*   **Result**：是 Rust 对健壮性的承诺。它强迫你在写代码时就思考“如果失败了怎么办”。
*   **? 运算符**：让错误传播变得像直线代码一样流畅，消除了回调地狱和层层 `if err != nil`。
*   **Panic**：是最后的手段，用于处理那些“本不该发生”的 Bug。

掌握了错误处理，你的代码就从“玩具”变成了“工程级产品”。下一章，我们将探索 Rust 强大的抽象能力：**泛型、Trait 和生命周期**！🧬