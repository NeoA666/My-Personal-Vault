
## 动态数组

**动态数组`Vec<T>`**，利用`Vec::new()`来声明一个空动态数组（必须显式声明数据类型），或者使用`vec！`宏来快速初始化一个动态数组

利用push和pop方法插入和删除值

离开作用域时，动态数组被销毁

两种读取方式：
- 利用&和[]直接返回元素的引用

- 利用get的方法返回一个`Option<T>`，用于处理非法请求，避免程序崩溃

当持有一个不可变引用时，不能使用push或pop，因为内存可能会被清除并分配新的内存空间，导致指向内存空间的位置无实际数据，导致悬垂指针

利用`for`来遍历动态数组，通过`*`来获取数组中的值并修改

#### 利用枚举来存储多个类型的值

通过使用枚举的不同变体储存不同类型的值，实现动态数组存储不同类型的数据，返回的都是枚举类型

## 字符串

两种字符串类型：
- 第一种，位于Rust语言核心部分的字符串切片`&str`，通常以借用的形式出现
- 第二种，被定义在Rust标准库中的String的字符串类型

### 创建一个字符串

利用`String::new()`创建一个空字符串，利用`String::from(内容)`或者`to_string(变量)`实现对字符串的初始化

### 更新字符串

向字符串中添加内容，利用`push`向字符串尾端添加一个字符，利用`push_str`向字符串添加一个字符串切片

利用 + 运算符实现两个字符串拼接，第二个字符串需要使用引用符，且在操作后第一个字符串所有权发生转移不能再次使用

+运算符会调用一个add方法，只会允许一个字符串变量与字符串切片变量相加，当时当我们将两个字符串相加时，编译器会使用解引用强制转换将&String转换为&str，且add方法会取得self的所有权

format!使用示例：
	`s = format!("{}-{}-{}",s1,s2,s3);`

### 字符串三种视角

- 第一种，字符簇，最接近人们眼中字母的概念
- 第二种，Unicode标量值，就是char类型，一般来说包括字母和音标
- 第三种，字节，String实际上是一个基于`Vec<u8>`的封装类型，不同的语言的词在UTF-8中对应着不同的字符数，因此不能用索引获取字符串

字符串切片时使用数字范围确定切片范围是不正确的，需要填写具体的范围实现切片

### 遍历字符串

利用`char()`方法返回字符串的Unicode标量值，利用`bytes()`方法返回每个原始字节

## 哈希映射

反应一种映射关系，在内部的实现使用了哈希函数，类似于Python中的字典

### 创建和初始化

利用new()来创建一个空哈希映射，通过insert方法添加元素，同时附加一个键和一个值；或者通过在一个由键值对组成的元组动态数组上使用collect方法

```Rust
use std::collections::HashMap;    //使用频率较低，不在预导入模块中

let teams = vec![String::from("Blue"),String::form("Yellow")];
let inital_scores = vec![10,50];

let scores:HashMap<_, _> =    //这里的HashMap<_, _>使用了占位符，让Rust自动推出类型
teams.iter().zip(inital_scores.iter()).collect();
```

### 所有权

实现了Copy Trait的类型，只会简单地复制到哈希映射中，而其他的类型会将所有权转交给哈希映射

### 访问

使用get方法访问键值对，成功返回一个键对应的值，未找到则会简单地返回None；也可以用for循环实现对哈希映射的遍历

### 更新

可以直接赋值来覆盖旧值

使用`entry`专用API在一个键没有对应值时插入一个值，`entry`会返回一个`Entry`的枚举作为结果，在值存在时不进行任何操作，而在键和值不存在时插入一个新的键值对，使用or_insert方法

基于旧值来更新值
获取一个指向关联值的可变引用，再使用解引用符实现对值的修改

#### 哈希函数

Hashmap的默认哈希函数算法是在密码学上安全的，但性能会下降，当你有需求时可以更换其他的哈希函数