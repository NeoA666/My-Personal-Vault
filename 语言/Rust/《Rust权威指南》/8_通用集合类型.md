# 📚 第八章：常见集合 (Collections)

Rust 的标准库提供了一系列强大的集合，它们的数据都存储在**堆 (Heap)** 上，这意味着它们的大小在编译时是未知的，可以动态增长。

## 1. 动态数组 `Vec<T>` (Vector)

`Vec<T>` 是 Rust 中最常用的集合。它是一块连续的内存空间，只能存储**相同类型**的数据。

### 🚀 创建与更新
*   **宏魔法**：`let v = vec![1, 2, 3];` 这是最常用的初始化方式。
*   **手动挡**：`let mut v = Vec::new(); v.push(5);`。
    *   *注意*：一旦用了 `push`，变量必须声明为 `mut`。

### 🔍 读取元素的陷阱
Rust 提供了两种读取方式，对应两种哲学：

1.  **索引 (`&v[i]`)**：简单粗暴。
    *   *行为*：如果你访问越界，程序直接 **Panic**（崩溃）。
    *   *适用*：你确信索引一定存在。
2.  **Get 方法 (`v.get(i)`)**：安全优雅。
    *   *行为*：返回 `Option<&T>`。如果越界，返回 `None`。
    *   *适用*：处理不确定的输入。

### ⚠️ 借用规则的实战体现
```rust
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0]; // 创建不可变引用
v.push(6);         // 尝试创建可变引用（修改数据）
// println!("The first element is: {}", first); // ❌ 报错！
```
*   **为什么？** `push` 可能会导致 Vec 容量不足，需要**重新分配内存**（找块更大的地，把数据搬过去）。此时旧的内存地址（`first` 指向的地方）就失效了。为了防止这种悬垂指针，Rust 禁止在持有引用时修改 Vec。

### 💡 技巧：用枚举存异构数据
Vec 只能存同一种类型。如果你想存不同类型的数据（比如 Excel 的一行），可以用枚举包装一下：
```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}
let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
];
```

---

## 2. 字符串 (String)：最复杂的集合

Rust 的字符串之所以难，是因为它太**诚实**了。它暴露了 UTF-8 编码的底层复杂性。

### 🧵 两个概念
1.  **`String`**：拥有所有权的字符串。存储在堆上，可变，可增长。
    *   本质上就是一个封装过的 `Vec<u8>`。
2.  **`&str` (字符串切片)**：借用的视图。通常指向静态区（字面量）或堆上的某个片段。

### ➕ 拼接
*   **`push_str`**：追加。
*   **`+` 运算符**：`let s3 = s1 + &s2;`。
    *   *所有权*：`s1` 的所有权被夺走了（Move），`s2` 依然可用。
    *   *底层*：调用了 `fn add(self, s: &str) -> String`。
*   **`format!` 宏**：`let s = format!("{}-{}-{}", s1, s2, s3);`。
    *   *优势*：不会夺走任何所有权，代码更易读。

### 🚫 为什么不能用索引 `s[0]`？
这是一个经典面试题。
*   **原因 1：字节 != 字符**。Rust 字符串是 UTF-8 编码的。
    *   ASCII 字符占 1 字节。
    *   汉字（如“你好”）占 3 字节。
    *   如果你访问 `s[0]`，你可能拿到半个汉字，这是没意义的。
*   **原因 2：性能陷阱**。用户期望 `s[i]` 是 O(1) 的操作，但由于 UTF-8 是变长的，要找到第 i 个字符必须从头遍历，这是 O(n)。

### 👁️ 三种视角
1.  **字节 (`bytes()`)**：最底层。`[228, 189, 160]`。
2.  **标量值 (`chars()`)**：Unicode 字符。`['你', '好']`。
3.  **字形簇 (Grapheme Clusters)**：人类眼中的“字符”。Rust 标准库不直接支持，需要第三方库（如 `unicode-segmentation`）。

---

## 3. 哈希映射 `HashMap<K, V>`

Python 的 Dict，Java 的 HashMap，Rust 的 HashMap。

### 🛠️ 基本操作
*   **引入**：`use std::collections::HashMap;` （不在预导入模块中）。
*   **所有权**：
    *   实现了 Copy 的类型（如 i32）会被复制。
    *   没实现 Copy 的类型（如 String）会被 **Move** 进 HashMap。

### 🔄 更新的艺术：Entry API
统计单词出现次数的经典代码：

```rust
let text = "hello world wonderful world";
let mut map = HashMap::new();

for word in text.split_whitespace() {
    // entry(word): 给我这个键的入口
    // or_insert(0): 如果没有值，插入 0
    // 返回一个可变引用 &mut V
    let count = map.entry(word).or_insert(0);
    
    // 直接解引用修改值
    *count += 1;
}
```
这段代码非常 Rustacean：既安全又高效（只查找一次）。

### 🔒 哈希算法
默认使用 **SipHash**，能抵抗哈希碰撞攻击（安全性高），但速度不是最快的。
*   如果你追求极致性能（比如做 LeetCode），可以换成 `FxHash` 等其他 Hasher。

---

## 🎓 总结

*   **Vec**：你的默认列表选择。小心扩容时的借用规则。
*   **String**：由于 UTF-8，它是无法索引的。请用 `chars()` 或切片来操作。
*   **HashMap**：不仅是 K-V 存储，它的 `entry` API 是处理“存在即更新，不存在即插入”逻辑的神器。

掌握了这三样武器，你已经可以写出绝大多数应用程序的业务逻辑了！下一章，我们将学习如何处理那些意料之外的情况：**错误处理**。🐛