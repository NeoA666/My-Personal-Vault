
## 基础概念

- **包**（package）：一个用于构建，测试并分享单元包的Cargo功能
- **单元包**（create）：一个用于生成库或可执行文件的**树形模块结构**
- **路径**：一种用于命名条目的方法，这些条目包括结构体，函数和模块等

```Rust
my_package/                      <-- package（由 Cargo.toml 定义）
├─ Cargo.toml
└─ src/
   ├─ lib.rs        ← library crate 的根（crate / 单元包）
   ├─ main.rs       ← binary crate 的根（另一个 crate / 单元包，可选）
   ├─ a.rs          ← 模块 a（由 lib.rs 中的 `pub mod a;` 引入）
   └─ a/
      └─ b.rs       ← 模块 a::b（b 是 a 的子模块；在 a.rs 中写 `pub mod b;`）
```

- 用 cargo new 包名 创建的是一个 package（由 Cargo.toml 表示）的项目目录
- 一个 package 可以包含 0 或 1 个 library crate（根是 src/lib.rs）和任意多个 binary crates（根是 src/main.rs 或 src/bin/*.rs）。cargo new 默认创建一个 binary crate（src/main.rs）；cargo new --lib 默认创建一个 library crate（src/lib.rs）
- 要增加额外的可执行程序，就在 src/bin 下添加文件（每个文件是一个单独的二进制 crate）

## 通过定义模块来控制作用域及私有性

我们通过`mod`关键词来定义一个模块，接着指明模块的名字，模块内可以定义新的模块或者定义其他条目（结构体，枚举，变量，trait等）

**模块树**展示各模块之间的嵌套关系，可以用家庭关系来描述，整个模块数都被放在一个名为create的隐式根模块下

## 用于在模块中指明条目的路径

### 两种方式

- **绝对路径**：利用模块树展示的结构，从create根节点开始写一段路径引用

- **相对路径**：同样使用模块树展示的结构，但是从引用的同级文件开始写路径引用

模块不仅仅被用于组织代码，还定义来Rust中的私有边界

Rust中的所有条目默认都是私有的。处于父级模块中的条目无法使用子模块中的私有条目，但是子模块可以使用所有祖先模块中的条目，并且能够感知上下文环境

## 使用pub关键词暴露路径

使用函数时，要确保它的所有的父模块都使用`pub`进行暴露

## 使用super关键词构造相对路径

利用super关键词，我们可以跳转到该条目的父模块并在与父模块同级的文件中寻找需要的条目

## 将结构体或枚举声明为公共的

我们在结构体定义前使用`pub`时，结构体本身就称为了一个公共结构体，但它的字段仍保持私有状态，我们可以逐一决定是否将某个字段展开，同时应该定义一个函数，函数包含对私有字段的操作，确保我们能够对该结构体创建实例

由于枚举只有在所有变体都公共可用时才能达到最大的功效，因此所有的枚举变体在枚举被pub时都默认是公共的

## Use关键词

*很像python中的import*，用于导入外部包或自己创建的一些lib包

通过绝对路径或相对路径导入，且一般保留一级父模块

利用as关键词或添加父模块名解决函数同名问题

利用pub use组合实现一个条目在新的作用域中被其他任意代码使用

使用外部包流程：首先将其列入Cargo.toml文件中，接着使用use来将特定条目引入作用域

使用嵌套解决众多use语句：`use std::io::{self,Write};`

通配符：*

