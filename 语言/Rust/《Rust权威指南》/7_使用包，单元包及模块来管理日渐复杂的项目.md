# 📦 第七章：使用包、Crate 和模块管理项目

## 1. 基础概念辨析 (The Big Picture)

Rust 的模块系统有三个层级，请务必分清：

1. **包 (Package)**：
    - **定义**：由 `Cargo.toml` 定义的一个项目整体。
    - **包含**：可以包含 1 个库 Crate（可选） + 任意个二进制 Crate。
    - _比喻_：这就像一个快递包裹。
2. **单元包 (Crate)**：
    - **定义**：编译的基本单元。
    - **分类**：
        - **Binary Crate**：生成可执行文件。入口是 `src/main.rs`。
        - **Library Crate**：生成库，供他人调用。入口是 `src/lib.rs`。
    - _比喻_：包裹里的具体产品。
3. **模块 (Module)**：
    - **定义**：Crate 内部的代码组织形式，形成树状结构。
    - _比喻_：产品的内部零件和隔间。

### 📂 典型文件结构

你的树形图非常标准，我稍微补充一下 `src/bin` 的情况：

Text

```
my_package/
├── Cargo.toml
└── src/
    ├── lib.rs          // [库 crate] 的根
    ├── main.rs         // [二进制 crate] 的根 (默认名称与包名相同)
    ├── bin/            // 这里面的每个文件都会被编译成独立的 [二进制 crate]
    │   └── another.rs  
    └── garden/         // 模块文件夹
        └── vegetables.rs // 子模块 garden::vegetables
```

---

## 2. 模块定义与私有性边界 (Modules & Privacy)

### `mod` 关键字

- **作用**：定义一个模块。
- **隐式根**：所有代码都在一个隐式的根模块 `crate` 下。

### 🔒 私有性规则 (Privacy Rules)

Rust 的默认策略是：**对外封闭，对内开放**。

1. **默认私有**：模块里的函数、结构体、字段，默认外面都看不见。
2. **父子关系**：
    - **父调子**：父模块无法访问子模块的私有条目（必须加 `pub`）。
    - **子调父**：子模块可以随意访问祖先模块的所有内容（哪怕是私有的）。
    - _比喻_：孩子可以翻家里的冰箱（祖先），但爸爸不能翻孩子的日记本（子模块私有），除非孩子把日记本摊开放在桌上（pub）。

### `pub` 关键字

想让别人用，必须加 `pub`。

- **注意**：如果你想用深层模块的函数 `crate::A::B::func()`，那么 `mod A`, `mod B`, `fn func` **全都要加 `pub`**。只要中间断了一层，外面就进不去。

### `super` 关键字

- **作用**：访问父级模块。
- _比喻_：类似文件系统里的 `..`。

---

## 3. 结构体与枚举的 Pub 细节

这里有个重要的不对称设计：

### 🏗️ 结构体 (Struct)

- **pub struct**：只把结构体名字公开了，里面的字段**依然是私有的**！
- **原因**：为了封装性。你可以隐藏某些内部状态，强制用户通过方法来修改。
- **后果**：如果结构体有私有字段，你必须提供一个公共的构造函数（如 `new()`），否则外部无法创建它的实例。

### 🚦 枚举 (Enum)

- **pub enum**：一旦枚举公开，**所有的变体 (Variants) 自动公开**。
- **原因**：枚举的实用性全在于它的变体。如果变体是私有的，这个枚举就没法用了（没法 match，没法赋值）。

---

## 4. `use` 关键字：引入路径

`use` 就像创建一个软链接（快捷方式），让你不用每次都写又臭又长的绝对路径。

### 🛣️ 引入习惯 (Idiomatic use)

1. **引入函数**：推荐引入到**父模块**。
    
    Rust
    
    ```
    use std::collections::HashMap; // ✅ 引入结构体：直接引入全名
    use std::fmt;                  // ✅ 引入函数/Trait：通常引入到父模块
    
    fn main() {
        let map = HashMap::new();  // 直接用
        fmt::Result...             // 通过模块名调用，清楚知道它来自 fmt
    }
    ```
    
    - _理由_：如果直接 `use std::fmt::Result`，代码里出现 `Result` 时，你分不清它是 `std::result::Result` 还是 `std::fmt::Result`。
2. **解决重名 (`as`)**：
    
    Rust
    
    ```
    use std::fmt::Result;
    use std::io::Result as IoResult; // 起个别名
    ```
    
3. **重导出 (`pub use`)**：
    
    - 这叫 **Re-exporting**。
    - _场景_：你内部代码结构很乱（`crate::module_a::sub_b::xx`），但你想给用户一个干净的接口（`crate::xx`）。你可以在根模块写 `pub use module_a::sub_b::xx;`。

### 📦 引入外部包

1. 先在 `Cargo.toml` 的 `[dependencies]` 里写上名字和版本。
2. Cargo 会自动下载。
3. 在代码里直接 `use`。

---

## 5. 模块拆分文件 (Splitting Modules)

这是新手最容易晕的地方。当你写 `mod garden;` 时，Rust 会去哪里找代码？

**现代 Rust (2018 Edition+) 的查找规则**： 如果在 `src/main.rs` 中写了 `mod garden;`，Rust 会按顺序找：

1. `src/garden.rs` （推荐，文件平铺）
2. `src/garden/mod.rs` （旧风格，文件夹嵌套）

同理，如果在 `src/garden.rs` 中写了 `mod vegetables;`，Rust 会找：

1. `src/garden/vegetables.rs`
2. `src/garden/vegetables/mod.rs`

---

## 🎓 总结

- **Package/Crate**：Package 是项目，Crate 是编译产物。
- **Mod**：组织代码的抽屉。默认私有。
- **Pub**：开锁的钥匙。结构体字段默认锁，枚举变体默认开。
- **Use**：快捷方式。
- **文件拆分**：`mod name;` 是声明，“我去别的文件找在这个名字的代码”。