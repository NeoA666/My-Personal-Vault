# 🦀 Rust 自动化测试学习笔记

在 Rust 编程中，测试就像是给你的代码穿上了一层“防弹衣”。无论你是修改旧代码还是添加新功能，自动化测试都能让你确信：**代码依然按照预期在工作，没有被意外改坏。**

Rust 语言原生内置了强大的测试支持，不需要安装额外的库就能跑起来。让我们一起来看看如何驾驭它。

---

## 📝 第一部分：如何编写测试

在 Rust 中，**测试本质上就是一个被 `#[test]` 属性标记的函数**。如果不加这个标记，它就是个普通函数；加了它，Rust 的测试运行程序（test runner）就会专门把它们挑出来运行。

### 1. 测试函数的构成

想象一个测试函数就像是一个“质检员”。它的工作流程通常分三步（AAA原则）：
1.  **Arrange（准备）**：设置好需要的数据或状态。
2.  **Act（行动）**：调用你想测试的代码。
3.  **Assert（断言）**：检查结果是不是你想要的。

```rust
#[cfg(test)]
mod tests {
    #[test] // 👈 这个属性告诉 Rust：“我是个测试函数”
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
```
> **运行方式**：在终端输入 `cargo test`，Rust 就会自动寻找并运行所有标有 `#[test]` 的函数。

此外，Rust在测试中会自动启用多线程，为每个测试分配一个独立的线程，并有一个主线程监视测试线程。

### 2. 使用 `assert!` 宏检查结果

`assert!` 是最基础的断言工具，它接受一个布尔值（Boolean）。
*   如果结果是 `true`，测试通过（绿灯 ✅）。
*   如果结果是 `false`，测试失败（红灯 ❌），程序会 panic。

**比喻**：这就像过安检，只要条件符合（true）就放行，不符合（false）就报警。

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

#[test]
fn larger_can_hold_smaller() {
    let larger = Rectangle { width: 8, height: 7 };
    let smaller = Rectangle { width: 5, height: 1 };

    // 我们断言 larger.can_hold(&smaller) 应该返回 true
    assert!(larger.can_hold(&smaller)); 
}
```

### 3. 使用 `assert_eq!` 和 `assert_ne!` 判断相等性

这两个宏专门用来比较两个值：
*   `assert_eq!(left, right)`：断言左边 **等于** 右边。如果不等，它会贴心地把左右两边的值都打印出来，让你知道错在哪。
*   `assert_ne!(left, right)`：断言左边 **不等于** 右边。如果相等，测试反而失败。一般用于程序员知道传入值一定不为某些值时。

```rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[test]
fn it_adds_two() {
    // 检查 add_two(2) 的结果是否严格等于 4
    assert_eq!(4, add_two(2)); 
}
```

失败时，会打印两个进行比较的数值，便于用户处理错误。

### 4. 添加自定义的错误提示信息

有时候，光报错说“测试失败”还不够，你希望能留下一句“遗言”，告诉自己当时为什么测试这个。你可以在 `assert` 系列宏的最后添加自定义字符串。

```rust
pub fn greeting(name: &str) -> String {
    format!("Hello {}!", name)
}

#[test]
fn greeting_contains_name() {
    let result = greeting("Carol");
    // 如果出错，会打印出后面的 "Greeting did not contain..." 
    assert!(
        result.contains("Carol"),
        "Greeting did not contain name, value was `{}`", // 自定义错误信息
        result
    );
}
```

### 5. 使用 `should_panic` 检查恐慌

有时候，代码**崩溃**才是正确的反应（比如有人传入了非法参数）。我们要测试“代码是否按预期崩溃了”。
这时候就需要给测试函数加上 `#[should_panic]` 属性。

*   如果不崩溃，测试失败。
*   如果崩溃了，测试通过。

为了防止代码因为“错误的理由”崩溃（比如拼写错误导致的崩溃，而不是逻辑校验导致的崩溃），最好加上 `expected` 参数来匹配 panic 的信息。

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }
        Guess { value }
    }
}

#[test]
#[should_panic(expected = "must be between 1 and 100")] // 👈 指定期待的 panic 信息片段
fn greater_than_100() {
    Guess::new(200); // 这里应该 panic，如果 panic 了，测试就通过
}
```

### 6. 使用 `Result<T, E>` 编写测试

除了使用 `panic!` 导致测试失败，你也可以让测试函数返回 `Result`。
*   返回 `Ok(())`：测试通过。
*   返回 `Err(String)`：测试失败。

这种写法的好处是你可以在测试中使用 `?` 操作符，代码会更整洁。

```rust
#[test]
fn it_works() -> Result<(), String> {
    if 2 + 2 == 4 {
        Ok(())
    } else {
        Err(String::from("two plus two does not equal four"))
    }
}
```

---

## ⚙️ 第二部分：控制测试的运行方式

`cargo test` 编译并运行测试时，它会生成一个二进制文件。默认行为是并行运行所有测试，并捕获输出。但我们可以通过命令行参数来改变这些行为。

### 1. 并行或串行地进行测试

默认情况下，Rust 会开启多个线程**并行**跑测试，这样速度快。
**隐患**：如果你的测试都要读写同一个文件，并行跑可能会导致数据打架（竞态条件），导致测试忽过忽挂。

**解决方案**：强制单线程串行运行。
```bash
$ cargo test -- --test-threads=1
```

### 2. 显示函数输出

默认情况下，如果你使用了 `println!` 打印调试信息：
*   如果测试**通过**，Rust 会**吞掉**这些输出，保持界面清爽。
*   只有测试**失败**，Rust 才会把打印的内容显示出来。

如果你非要看所有测试的打印信息（哪怕是通过的），可以使用：
```bash
$ cargo test -- --show-output
$ cargo test -- --nocapture # 两者都可以
```

### 3. 只运行部分特定名称的测试

如果你有 100 个测试，改了一个小功能，只想测那一个，不用全跑一遍。
你可以直接跟上测试函数的名称（或者名称的一部分）。

```bash
# 只运行名为 "one_hundred" 的测试
$ cargo test one_hundred

# 运行所有名字里包含 "add" 的测试（比如 add_two, add_three），满足正则匹配
$ cargo test add
```

### 4. 通过显式指定来忽略某些测试

有些测试特别慢（比如涉及网络请求或大文件读写），平时开发不想每次都跑。可以加上 `#[ignore]` 属性。

```rust
#[test]
#[ignore] // 👈 平时运行 cargo test 会跳过它
fn expensive_test() {
    // 需要跑很久的代码...
}
```

如果你哪天心情好，或者要发版了，想专门跑这些被忽略的测试：
```bash
$ cargo test -- --ignored
```

---

## 🏗️ 第三部分：测试的组织结构

Rust 社区通常把测试分为两类：**单元测试** 和 **集成测试**。这就像是“零件检测”和“整机组装检测”的区别。

### 1. 单元测试 (Unit Tests)

*   **目的**：测试代码的最小单元（通常是一个函数），尽量隔离外部环境。
*   **位置**：直接写在业务代码的**同一个文件**中。
*   **私有性**：单元测试有特权，**可以测试私有函数 (private functions)**。

通常的惯例是在文件底部创建一个名为 `tests` 的模块，并标记为 `#[cfg(test)]`。

**为什么要写在同一个文件？**
因为 Rust 认为测试也是代码说明书的一部分，而且这样能方便地测试私有逻辑。

```rust
// src/lib.rs

// 私有函数，外部无法访问
fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

// 单元测试模块
#[cfg(test)] // 👈 只有在运行 cargo test 时才编译这个模块
mod tests {
    use super::*; // 引用父模块的所有内容

    #[test]
    fn internal() {
        // 单元测试可以直接调用私有函数！
        assert_eq!(4, internal_adder(2, 2));
    }
}
```

### 2. 集成测试 (Integration Tests)

*   **目的**：从库的外部使用者角度进行测试，验证各个模块能不能配合好。
*   **位置**：必须放在项目根目录下的 **`tests` 目录**中（与 `src` 平级）。
*   **权限**：集成测试完全把你的库当作一个外部 crate，**只能访问 `pub` 公开的 API**，不能测私有函数。

**文件结构示例**：
```text
my_project
├── Cargo.toml
├── src
│   └── lib.rs
└── tests  <-- 集成测试目录
    ├── integration_test.rs
    └── common
        └── mod.rs
```

**代码示例 (`tests/integration_test.rs`)**：
不需要 `#[cfg(test)]`，因为 `tests` 目录下的文件本来就只在测试时编译。
```rust
use my_project; // 像导入第三方库一样导入自己的库

#[test]
fn it_adds_two() {
    assert_eq!(4, my_project::add_two(2));
}
```

> **小技巧**：如果你想在集成测试中复用一些辅助代码（比如 `setup` 函数），可以创建一个 `tests/common/mod.rs` 文件。Rust 不会把 `common` 视为一个独立的测试 crate，而是作为模块供其他测试文件调用。

---

## 🎓 总结

Rust 的自动化测试体系非常完善且符合直觉，它鼓励我们**边写代码边写测试**。

*   **断言工具**：用 `assert!`, `assert_eq!` 做标尺，用 `should_panic` 测异常，用 `Result` 测流程。
*   **控制权**：你可以全速并行跑，也可以单线程调试，或者只跑某几个特定的测试。
*   **组织架构**：
    *   **单元测试**是贴身保镖，住在源代码文件里，连私有函数也能测。
    *   **集成测试**是外部审计员，住在 `tests` 目录，模拟真实用户的用法。

记住，好的测试不仅能证明你的代码现在是工作的，更能保证未来的你（或你的同事）不会不小心把它改坏。Happy Testing! 🦀 ✅