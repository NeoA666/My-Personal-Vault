**结构体和枚举类型是用来创建新类型的基本工具**，这些新类型同样可以享受到Rust编译时类型检查系统的所有优势

## 定义并实例化结构体

*不在赘述，仅讲要点或不同点*

- 一旦实例可变，那么实例中的所有字段都是可变的，**Rust不允许单独声明某一部分的可变性**

- 两个语法糖：
	利用函数构建新实例时，当字段名与参数有相同名字时，可以仅书写字段名

	利用。
- 结构体元组：当你不需要声明每个值的实际意义时使用

- 空结构体可以实现trait

## 一个使用结构体的实例

一个问题：[[不同语意下的trait]] ^9a0341

**派生Trait**问题见上方的双向链接

```Rust
#[derive(Debug)] //使println！()使用Debug格式化命令输出结构体内容

struct Rectangle {

width: u32,

height: u32,

}//使长和宽两个有实际意义的数值关联起来

  

//在impl后面编写方法用于指定结构体的行为

impl Rectangle {

fn area(&self) -> u32 {

self.width * self.height

}

  

fn can_hold(&self, other: &Rectangle) -> bool {

self.width > other.width && self.height > other.height

}

//这是一个关联函数，不用接受self作为参数 例：String::from

fn square(size: u32) -> Rectangle {

Rectangle {

width: size,

height: size,

} //也是一个表达式

} //常用作构造器实现新实例的构建，这里用于构建一个新的正方形实例

}

  

fn main() {

let rect1 = Rectangle {

width: 30,

height: 50,

};

let rect2 = Rectangle {

width: 20,

height: 40,

};

  

println!("rect1 is {:#?}", rect1); //使println！()使用Debug格式化命令输出结构体内容

  

println!(

"The area of the rectangle is {} square pixels.",

rect1.area()

);

  

println!("Can rect1 hold rect2?{}", rect1.can_hold(&rect2));

}
```

## 方法

运算符`->`去哪了：在C++中，`->`符号用于获取指针类参数的成员变量，而在Rust中，作为替代，设计了一种名为**自动引用和解引用的功能**，会自动添加诸如`&；&mut；*`等符号

例：
```Rust
p1.distance(&p2);
(&p2).distance(&p2);
//两者等价
```

## 总结

使用结构体，我们能够组合关联数据，赋予数据名字，使数据的含义更加清晰

方法可以让我们为结构体实例指定行为，而关联函数则可以把那些不需要实例的特定功能放置到结构体的命名空间中
