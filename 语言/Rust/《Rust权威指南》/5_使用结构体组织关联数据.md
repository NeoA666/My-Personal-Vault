# 🏗️ 第五章：使用结构体组织关联数据

## 1. 定义与实例化：Rust 的特色细节

结构体（Struct）让你能把相关联的数据打包在一起。除了基础语法，有几个 Rust 特有的点需要注意：

### 🔑 关键特性

1. **全员可变性 (All or Nothing)**：
    - Rust 不允许只把结构体的某个字段设为 `mut`。
    - 一旦你声明实例是 `mut` 的，所有字段都可变；否则全不可变。
2. **字段初始化简写 (Field Init Shorthand)**：
    
    - 如果变量名和字段名一样，可以偷懒只写变量名。
    
    Rust
    
    ```
    fn build_user(email: String, username: String) -> User {
        User {
            email,      // 等同于 email: email
            username,   // 等同于 username: username
            active: true,
        }
    }
    ```
    
3. **结构体更新语法 (Update Syntax)**：
    - 基于旧实例创建新实例，复用部分字段。
    - `..user1` 必须放在最后。
    - _注意_：这会涉及**所有权转移**！如果 `user1` 里有 String 类型的字段被移给了 `user2`，`user1` 就不能用了。

### 🧩 特殊结构体

- **元组结构体 (Tuple Structs)**：`struct Color(i32, i32, i32);`。有类型名，但字段没名字。
- **单元结构体 (Unit-Like Structs)**：`struct AlwaysEqual;`。没有字段，常用于实现某个 Trait 而不需要存数据。

---

## 2. 结构体实例演练：矩形面积

这段代码展示了 Rust 面向对象风格的一面（虽然 Rust 不是纯 OO 语言）。

### 🏷️ 派生 Trait (`#[derive]`)

你遇到了一个关于 Trait 语义的问题：[[不同语意下的trait]] ^9a0341

在 Rust 中，很多基础功能（如打印调试信息、比较相等、复制）都不是默认提供的，你需要显式地“派生”它们。

- `#[derive(Debug)]`：让编译器自动为你的结构体实现 `Debug` Trait，这样你就能用 `{:?}` 或 `{:#?}` 打印它了。

### 💻 完整代码解析

Rust

```
#[derive(Debug)] // 👈 魔法注解：自动生成打印功能的代码
struct Rectangle {
    width: u32,
    height: u32,
}

// impl 块：专门用来定义方法和关联函数
impl Rectangle {
    // 1. 方法 (Methods)：第一个参数是 &self
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // 另一个方法：接收另一个 Rectangle 的引用
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }

    // 2. 关联函数 (Associated Functions)：不接收 self
    // 类似静态方法，常用于构造器 (Constructor)
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    // 调用关联函数创建实例
    let sq = Rectangle::square(10); 

    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 20, height: 40 };

    // 打印结构体
    println!("rect1 is {:#?}", rect1);

    // 调用方法
    println!("Area: {}", rect1.area());
    println!("Can hold? {}", rect1.can_hold(&rect2));
}
```

---

## 3. 方法 (Methods) 与 自动引用 (Automatic Referencing)

### 方法定义

- `impl` 块将函数与类型关联起来。
- **`&self`**：是 `self: &Self` 的语法糖。表示借用实例，而不是获取所有权。
    - 如果写成 `self`，调用方法后，实例的所有权就会被夺走（Move）。
    - 如果写成 `&mut self`，则是可变借用。

### 🚀 消失的 `->` 运算符

C++ 程序员可能会找 `->` 箭头运算符。Rust 把它优化掉了。

**自动引用和解引用 (Automatic Referencing and Dereferencing)**： 当你调用 `object.method()` 时，Rust 编译器会自动根据方法的签名（是 `self`, `&self` 还是 `&mut self`）为 `object` 添加引用 `&`、`&mut` 或解引用 `*`。

Rust

```
// 假设 p1 是 Point 实例
p1.distance(&p2);

// 编译器实际上帮你做的事：
(&p1).distance(&p2); 
```

这使得代码更加整洁，你不用时刻纠结到底是操作指针还是操作值。

---

## 🎓 总结

- **结构体**：数据的容器。记得 `derive(Debug)` 方便调试。
- **impl 块**：逻辑的容器。将数据（字段）和行为（方法）分开定义，但逻辑上绑定。
- **关联函数**：不带 `self` 的函数，通常用作构造器（如 `String::from` 或 `Rectangle::square`）。
- **语法糖**：字段初始化简写和自动引用机制，体现了 Rust 在保证底层控制力的同时，也在极力提升开发体验。